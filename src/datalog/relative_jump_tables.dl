//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/


.decl data_word(EA:address,Size:unsigned,Val:number)
.output data_word

data_word(EA,2,Val):-
    data_byte(EA,Byte0), EA % 2 = 0,//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    Byte1 < 128,//the number is positive
    Val = as(Byte1*2^8 + Byte0,number).

data_word(EA,4,Val):-
    data_byte(EA,Byte0),
    (binary_format("PE"); EA % 4 = 0),//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    (
        Byte3 >= 128,//the number is negative
        Val = -(2^32 -as( Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number)),
        Val != 0
        ;
        Byte3 < 128,//the number is positive
        Val =  as(Byte3*2^24+ Byte2*2^16 + Byte1*2^8 + Byte0,number)
    ).

data_word(EA,8,Val):-
    data_byte(EA,Byte0),
    (binary_format("PE"); EA % 8 = 0),//jump tables are assumed to be aligned
    data_byte(EA+1,Byte1),
    data_byte(EA+2,Byte2),
    data_byte(EA+3,Byte3),
    data_byte(EA+4,Byte4),
    data_byte(EA+5,Byte5),
    data_byte(EA+6,Byte6),
    data_byte(EA+7,Byte7),

    Val =  as((Byte7*2^56)  bor (Byte6*2^48)   bor (Byte5*2^40)  bor (Byte4*2^32) +
           (Byte3*2^24) bor (Byte2*2^16) bor (Byte1*2^8) bor Byte0,number).


.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

These jump tables seem to have entries of sizes 4 or 8 only.
Jump tables with entry sizes of 1 or 2 appear in data and can be detected later.

In these jump tables, the reference address coincides with the starting address
of the jump table.
*/
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)
.output relative_address

.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)

relative_address_start(EA,Size,EA,Dest,DestIsFirstOrSecond):-
    take_address(_,EA),
    EASigned = as(EA,number),
    data_word(EA,Size,Diff),
    // This is according to what we have seen generated by ICC
    (
        Size = 4, Diff <= 0
        ;
        Size = 8
    ),
    // sometimes the jump table entry is Diff = Reference-JumpTarget
    // and sometimes it is Diff = JumpTarget-Reference
    (
        Dest = as(EASigned-Diff,address), DestIsFirstOrSecond = "second"
        ;
        Dest = as(EASigned+Diff,address), DestIsFirstOrSecond = "first"
    ),
    possible_ea(Dest).

relative_address(EA,Size,EA,Ref,Dest,DestIsFirstOrSecond):-
    relative_address_start(EA,Size,Ref,Dest,DestIsFirstOrSecond).

relative_address(EA+Size,Size,TableStart,Ref,Dest,DestIsFirstOrSecond):-
    relative_address(EA,Size,TableStart,Ref,_,DestIsFirstOrSecond),
    data_word(EA+Size,Size,Diff),
    RefSigned = as(Ref,number),
    (
        DestIsFirstOrSecond = "second", Dest = as(RefSigned-Diff,address),Size >= 4;
        DestIsFirstOrSecond = "first", Dest = as(RefSigned+Diff,address)
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// detect jump tables precisely once we have all results of the analyses


// auxiliary predicate for detecting accessing an element of a jump table.
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address)

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE","NONE",RegIndex,as(Size,number),TableStart,Size),
    TableStartAddr = as(TableStart,address),
    RegIndex != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,1,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,"NONE",_,TableStart,1),
    TableStartAddr = as(TableStart,address),
    RegBase != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,as(Size,number),_,Size),
    RegIndex != "NONE",
    def_used(EA_regdef,RegBase,EA,_),
    value_reg(EA_regdef,RegBase,_,"NONE",0,TableStart,_),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

// sometimes the regBase contains the index (already multiplied)
// and the regIndex contains the base address
jump_table_element_access(EA,Size,TableStartAddr):-
    data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
    RegBase != "NONE",
    def_used(EA_regdef,RegIndex,EA,_),
    value_reg(EA_regdef,RegIndex,_,"NONE",0,TableStart,_),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.


.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Operation:symbol)
.output jump_table_start

//  mov REG, Size [REG*Size+TableStart] or mov REG, Size [REG*Size+ RegBase] where RegBase = TableStart
//  add REG, TableReference
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Operation):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    op_immediate_and_reg(EA_base,Operation,Reg,_,TableReference),
    TableReferenceAddr = as(TableReference,address),
    (
        Operation= "ADD";
        Operation= "SUB"
    ),
    def_used(EA_read,Reg,EA_base,_),
    jump_table_element_access(EA_read,Size,TableStart),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

//  mov REG2, TableReference
//  mov REG, Size PTR [_*Size+TableStart] or mov REG, Size [_*Size+ RegBase] where RegBase = TableStart
//  add REG, REG2 (or add REG2,REG)
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Operation):-
    (
        reg_call(EA_jump,_);
        reg_jump(EA_jump,_)
    ),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    arch.reg_reg_arithmetic_operation(EA_base,Reg,Reg,Reg2,Mult,0),
    (
        Mult = 1,Operation= "ADD";
        Mult = -1,Operation= "SUB"
    ),
    (
        RegBase = Reg, RegDiff = Reg2;
        RegBase = Reg2, RegDiff = Reg
    ),
    def_used(EA_read,RegBase,EA_base,_),
    jump_table_element_access(EA_read,Size,TableStart),
    def_used(EA_def_ref,RegDiff,EA_base,_),
    value_reg(EA_def_ref,RegDiff,_,"NONE",0,TableReference,_),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

//  mov REG, TableReference
//  add REG, SIZE PTR [_*Size+TableStart] or mov REG, Size [REG*Size+ RegBase] where RegBase = TableStart
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Operation):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,Operation),
    (
        Operation = "ADD";
        Operation = "SUB"
    ),
    jump_table_element_access(EA_base,Size,TableStart),
    def_used(EA_def_ref,Reg,EA_base,_),
    value_reg(EA_def_ref,Reg,_,"NONE",0,TableReference,_),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

// mov EAX,EAX
// lea RDX,QWORD PTR [RAX*4]
// lea RAX,QWORD PTR [RIP+.L_f74b4]
// mov EAX,DWORD PTR [RDX+RAX*1]
// movsxd RDX,EAX
// lea RAX,QWORD PTR [RIP+.L_f74b4]
// add RAX,RDX
// jmp RAX
jump_table_start(EA_jump,Size,TableStart,TableReference,"ADD"):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,"ADD"),
    (
        RegBase = Reg, RegDiff = Reg2;
        RegBase = Reg2, RegDiff = Reg
    ),
    def_used(EA_def_diff,RegDiff,EA_base,_),
    instruction_get_operation(EA_def_diff,"MOVSXD"),
    def_used(EA_def_ref,RegBase,EA_base,_),
    take_address(EA_def_ref,TableStart),
    def_used(EA_def_diff2,_,EA_def_diff,_),
    data_access(EA_def_diff2,_,"NONE",_,_,_,_,Size),
    TableReference = TableStart.
