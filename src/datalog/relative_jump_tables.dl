//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/

.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

These jump tables seem to have entries of sizes 4 or 8 only.
Jump tables with entry sizes of 1 or 2 appear in data and can be detected later.

In these jump tables, the reference address coincides with the starting address
of the jump table.
*/
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)

.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)

relative_address_start(EA,Size,EA,Dest,DestIsFirstOrSecond):-
    take_address(_,EA),
    EASigned = as(EA,number),
    data_word(EA,Size,Diff),
    Diff != 0,
    (binary_format("PE"); EA % Size = 0), // jump tables are assumed to be aligned
    // Check if the second entry is reasonable, too.
    // This is based on the assumption that a jump-table consists of multiple
    // entries.
    data_word(EA+Size,Size,Diff2),
    Diff2 != 0,
    // This is according to what we have seen generated by ICC
    (
        Size = 4, Diff <= 0, Diff2 <= 0
        ;
        Size = 8,
        // The read addresses are not regular pointers already
        !relocation(EA,_,_,_,_,_,_)
    ),
    // sometimes the jump table entry is Diff = Reference-JumpTarget
    // and sometimes it is Diff = JumpTarget-Reference
    (
        Dest = as(EASigned-Diff,address), DestIsFirstOrSecond = "second",
        Dest2 = as(EASigned-Diff2,address)
        ;
        Dest = as(EASigned+Diff,address), DestIsFirstOrSecond = "first",
        Dest2 = as(EASigned+Diff2,address)
    ),
    possible_ea(Dest),
    possible_ea(Dest2).

relative_address(EA,Size,EA,Ref,Dest,DestIsFirstOrSecond):-
    relative_address_start(EA,Size,Ref,Dest,DestIsFirstOrSecond).

relative_address(EA+Size,Size,TableStart,Ref,Dest,DestIsFirstOrSecond):-
    relative_address(EA,Size,TableStart,Ref,_,DestIsFirstOrSecond),
    Size != 1,
    data_word(EA+Size,Size,Diff),
    Diff != 0,
    RefSigned = as(Ref,number),
    (
        DestIsFirstOrSecond = "second", Dest = as(RefSigned-Diff,address),Size >= 4;
        DestIsFirstOrSecond = "first", Dest = as(RefSigned+Diff,address)
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// detect jump tables precisely once we have all results of the analyses

// auxiliary predicate for detecting accessing an element of a jump table.
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address,RegIndex:register)

jump_table_element_access(EA,Size,TableStartAddr,RegIndex_nn):-
    data_access(EA,_,"NONE","NONE",RegIndex,as(Size,number),TableStart,Size),
    reg_nonnull(RegIndex,RegIndex_nn),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,1,TableStartAddr,RegBase_nn):-
    data_access(EA,_,"NONE",RegBase,"NONE",_,TableStart,1),
    reg_nonnull(RegBase,RegBase_nn),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr,RegIndex_nn):-
    data_access(EA,_,"NONE",RegBase,RegIndex,as(Size,number),Offset,Size),
    reg_nonnull(RegBase,RegBase_nn),
    reg_nonnull(RegIndex,RegIndex_nn),
    const_value_reg_used(EA,_,_,RegBase_nn,Base),
    TableStartAddr = as(Base+Offset,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

/**
The following case was observed in libc.so (v2.36):
movslq .L_191058(%rip),%rdi
leaq .L_191058(%rip),%r8
addq %r8,%rdi
jmpq *%rdi
...
.L_191058:
    .long .L_129b24-.L_191058
    .long .L_129db0-.L_191058
    .long .L_129d20-.L_191058
    .long .L_129ef0-.L_191058
    .long .L_129db0-.L_191058

In the data access, the base register is PC and there is no index register.
*/
jump_table_element_access(EA,Size,TableStartAddr,"NONE"):-
    pc_relative_operand(EA,1,TableStartAddr),
    data_access(EA,_,_,_,_,_,_,Size),
    def_used_for_address(EA,_,Type),
    (
        Type = "Jump"; Type = "Call"
    ),
    reg_def_use.def_used(EA,Reg1,EA_add,_),
    reg_def_use.def_used(EA2,Reg2,EA_add,_),
    take_address(EA2,TableStartAddr),
    arch.reg_reg_arithmetic_operation(EA_add,_,Reg2,Reg1,1,0),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

// sometimes the regBase contains the index (already multiplied)
// and the regIndex contains the base address
jump_table_element_access(EA,Size,TableStartAddr,RegBase_nn):-
    data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
    reg_nonnull(RegBase,RegBase_nn),
    reg_nonnull(RegIndex,RegIndex_nn),
    const_value_reg_used(EA,_,_,RegIndex_nn,TableStart),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

/**
Find sign extensions of the jump table element.
*/
.decl jump_table_signed(TableStart:address,Signed:unsigned)

// The value is explicitly extended when loaded from memory.
jump_table_signed(TableStart,Signed):-
    jump_table_element_access(EA,Size,TableStart,_),
    arch.extend_load(EA,Signed,8*Size).

// The register is explicitly extended.
jump_table_signed(TableStart,Signed):-
    jump_table_element_access(EA,Size,TableStart,_),
    value_reg(EA_used,_,EA,Reg,_,_,_),
    arch.extend_reg(EA_used,Reg,Signed,8*Size).

// The register is loaded, and then a larger version of that register is used.
jump_table_signed(TableStart,Signed):-
    jump_table_element_access(EA,_,TableStart,_),
    instruction_get_dest_op(EA,_,DstOp),
    op_regdirect(DstOp,DefReg),
    reg_map(DefReg,DefRegMapped),
    value_reg(EA_used,_,EA,DefRegMapped,_,_,_),
    instruction_get_src_op(EA_used,_,Op),
    op_regdirect(Op,UsedReg),
    reg_map(UsedReg,DefRegMapped),
    arch.register_size_bytes(DefReg,DefSize),
    arch.register_size_bytes(UsedReg,UsedSize),
    UsedSize > DefSize,
    // Using the larger register is an implicit zero-extension.
    Signed = 0.

jump_table_signed(TableStart,Signed):-
    // If the offset is already the right size, assume that it is signed.
    jump_table_element_access(_,Size,TableStart,_),
    arch.pointer_size(PtrSize),
    Size = PtrSize,
    Signed = 1.

/**
The end of a jump table as identified by a boundary value of the index register.
*/
.decl jump_table_max(TableStart:address,TableEnd:address)

jump_table_max(TableStart,TableStart+as(Value,unsigned)*Size):-
    jump_table_element_access(EA,Size,TableStart,RegIndex),
    code_in_block(EA,Block),
    (
        // The register was not previously defined in this block.
        !reg_def_use.block_last_def(EA,_,RegIndex),
        last_value_reg_limit(_,Block,RegIndex,Value,"MAX",_)
        ;
        // Register is defined in the block - check for a propagated limit.
        reg_def_use.block_last_def(EA,EA_def,RegIndex), UNUSED(Block),
        last_value_reg_limit(EA_def,_,RegIndex,Value,"MAX",_)
    ),
    Value >= 0.

// A common pattern in CL-generated binaries looks like:
//
// Load an index from a table
//      movzx EAX,BYTE PTR [RSI+RAX*1+(IMAGEREL $L_140009e74)]
// Use that to index into the actual jump table
//      mov EDX,DWORD PTR [RSI+RAX*4+(IMAGEREL $L_140009e64)]
//      add RDX,RSI
//      jmp RDX
//
// If we know the limit for the index used in the first load, we can find the
// possible indices for the second table.
//
// TODO: Currently, this generates a jump_table_max for *every* index value in
// the first table. This works since relative_jump_table_entry_candidate will
// propagate to the largest max.
// I think we could avoid this problem if Souffle supported recursive
// aggregates (currently in development, see https://github.com/souffle-lang/souffle/pull/2263)
// and range queries in aggregates (bug: https://github.com/souffle-lang/souffle/issues/2160).
// Alternatively, we could use subsumption to delete the smaller jump_table_max.
jump_table_max(TableStart2,TableStart2+IndexValue*Size2):-
    jump_table_element_access(EA1,Size1,TableStart1,_),
    jump_table_max(TableStart1,TableEnd1),
    reg_def_use.def_used(EA1,Reg,EA2,_),
    EA1 != EA2,
    jump_table_element_access(EA2,Size2,TableStart2,Reg),
    TableStart1 != TableStart2,
    TableAddress = range(TableStart1,TableEnd1+Size1,Size1),
    data_uword(TableAddress,Size1,IndexValue).

/**
A jump table begins at TableStart.
*/
.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)

jump_table_start(EA_jump,Size,TableStart,as(Base,address),Scale):-
    // Looks like a jump table access occurs at EA...
    jump_table_element_access(EA,Size,TableStart,_),
    // ...and the register defined at EA (Reg) is used as RegJump = Base + Reg * Scale
    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
    Reg != "NONE",
    // ...and something jumps to that register.
    reg_def_use.def_used(EA_add,RegJump,EA_jump,_),
    (
        reg_call(EA_jump,_);
        reg_jump(EA_jump,_)
    ),
    code(EA_jump).

//  mov REG, TableReference
//  add REG, SIZE PTR [_*Size+TableStart] OR sub REG, SIZE PTR [_*Size+TableStart]
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Scale):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    reg_def_use.def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,Operation),
    (
        Operation = "ADD", Scale=1;
        Operation = "SUB", Scale=-1
    ),
    jump_table_element_access(EA_base,Size,TableStart,_),
    const_value_reg_used(EA_base,_,_,Reg,TableReference),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

// mov EAX,DWORD PTR [ECX+EAX*4+.L_804a008@GOTOFF]   load
// add EAX,ECX                                       base
// jmp EAX                                           jump
jump_table_start(EA_jump,4,TableStart,TableReference,1):-
    binary_isa("X86"),
    got_reference_pointer(TableReference),
    // Load offset.
    got_relative_operand(EA_load,1,TableStart),
    reg_def_use.def_used(EA_load,Reg_got,EA_base,_),
    // Base is GOT.
    arch.reg_reg_arithmetic_operation(EA_base,Reg_jump,Reg_got,_,1,0),
    // Jump to register.
    reg_def_use.def_used(EA_base,_,EA_jump,_),
    reg_jump(EA_jump,Reg_jump).

// add ECX,DWORD PTR [ECX+EAX*4+.L_804a008@GOTOFF]
// jmp ECX
jump_table_start(EA_jump,4,TableStart,TableReference,1):-
    binary_isa("X86"),
    got_reference_pointer(TableReference),
    got_relative_operand(EA_add,1,TableStart),
    instruction_get_operation(EA_add,"ADD"),
    reg_def_use.def_used(EA_add,Reg_jump,EA_jump,_),
    reg_jump(EA_jump,Reg_jump).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// propagate jump tables

/**
Calculate the target for a relative jump table entry.
*/
.decl relative_jump_table_entry_target(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number) inline

relative_jump_table_entry_target(EA,TableStart,Size,Reference,NewDest,Scale):-
    jump_table_signed(TableStart,Signed),
    (
        Signed = 0, data_uword(EA,Size,UDiff),
        Reference_unsigned = as(Reference,unsigned),
        Dest = as(Reference_unsigned + as(Scale,unsigned)*UDiff,address)
        ;
        Signed = 1, data_word(EA,Size,SDiff),
        Reference_signed = as(Reference,number),
        Dest = as(Reference_signed + as(Scale,number)*SDiff,address)
    ),
    (
        // Target is code.
        code(Dest), NewDest = Dest;
        // Target is padding - forward to the next possible target.
        is_padding(Dest), after_end(Dest,End), after_end(NewDest,End), !is_padding(NewDest), code(NewDest)
    ).

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale

These are generated during value analysis, and referenced by value analysis,
so cannot negate any results of value analysis.

Some of these are discarded to form relative_jump_table_entry, which is used by
symbolization.
*/
.decl relative_jump_table_entry_candidate(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)

relative_jump_table_entry_candidate(TableStart,TableStart,Size,Reference,Dest,Scale,0):-
    !binary_isa("ARM"),
    jump_table_start(_,Size,TableStart,Reference,Scale),
    relative_jump_table_entry_target(TableStart,TableStart,Size,Reference,Dest,Scale),
    // The table is in a loaded section.
    loaded_section(SectionStart,SectionEnd,_),
    TableStart >= SectionStart, TableStart < SectionEnd.

// If we identified a limit to the size of the jump table using the boundary
// value analysis (jump_table_max), propagate it now and feed the result back
// into the value analysis.
// If a jump table is unbounded (i.e., no jump_table_max has been generated),
// then we have low confidence about its size. In this case, we defer
// propagating until the post-value-analysis refinement stage. Propagating
// unbounded tables would likely pollute value analysis results with
// questionable edges anyway.
//
// Propagate until finding:
// * jump table index boundary
// * something that doesn't resolve to a code pointer.
// * a symbol
// * the end of a data section

relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    !binary_isa("ARM"),
    relative_jump_table_entry_candidate(LastEA,TableStart,Size,Reference,_,Scale,Offset),
    EA = LastEA + Size,
    jump_table_max(TableStart,TableEnd),
    TableEnd >= EA,
    !symbol(EA,_,_,_,_,_,_,_,_),
    data_segment(BegData,EndData), BegData <= TableStart, EA+Size <= EndData,
    relative_jump_table_entry_target(EA,TableStart,Size,Reference,Dest,Scale).

.decl discarded_jump_table_entry(TableStart:address,TableRef:address,EA:address)

// Prefer jump tables where TableRef = TableStart, if there is a conflict.
discarded_jump_table_entry(TableStart,TableRef1,TableStart):-
    jump_table_start(_,_,TableStart,TableRef1,_),
    jump_table_start(_,_,TableStart,TableRef2,_),
    TableRef1 != TableStart,
    TableRef2 = TableStart.

// Truncate a jump table if a separate data access is encountered.
discarded_jump_table_entry(TableStart,Ref,EA):-
    relative_jump_table_entry_candidate(EA,TableStart,Size,Ref,_,_,_),
    (
        symbolic_operand(_,_,Limit,"data");
        data_segment(Limit,_);
        data_segment(_,Limit);
        jump_table_start(_,_,Limit,_,_)
    ),
    EA <= Limit, Limit < EA+Size,
    EA != TableStart.

// Recursively discard
discarded_jump_table_entry(TableStart,Ref,EA):-
    discarded_jump_table_entry(TableStart,Ref,DiscardEA),
    jump_table_start(_,Size,TableStart,Ref,_),
    EA = DiscardEA + Size,
    relative_jump_table_entry_candidate(EA,TableStart,Size,Ref,_,_,_).

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale.

These are generated after data access analysis, and used for symbolization and final
CFG generation. This allows using the final results of value analysis to
resolve overlapping jump tables.
*/
.decl relative_jump_table_entry(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)

relative_jump_table_entry(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,Dest,Scale,Offset),
    !discarded_jump_table_entry(TableStart,Reference,EA).

/**
Propagate unbounded jump tables

Jump tables with no jump_table_max are not propagated in the
relative_jump_table_entry_candidate relation since we have low confidence on
their boundaries. We propagate them now, in the refinement stage, where we
can negate more advanced analyses.

Since these were not propagated earlier, these edges were not used during value
analysis.
*/
relative_jump_table_entry(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    !binary_isa("ARM"),
    relative_jump_table_entry(LastEA,TableStart,Size,Reference,_,Scale,Offset),
    !jump_table_max(TableStart,_),
    EA = LastEA + Size,
    !symbol(EA,_,_,_,_,_,_,_,_),
    data_segment(BegData,EndData), BegData <= TableStart, EA+Size <= EndData,
    next_data_limit(Prev, Next), Prev < EA, Next >= EA+Size,
    relative_jump_table_entry_target(EA,TableStart,Size,Reference,Dest,Scale).
