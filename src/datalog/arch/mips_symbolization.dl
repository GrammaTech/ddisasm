//===- mips_symbolization.dl --------------------------------*- datalog -*-===//
//
//  Copyright (C) 2020-2023 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
MIPS architecture-specific rules for symbolization

-------------------------------------------------------------------------------
MIPS Symbolic Operand Attributes

1. %hi(symbol) / %lo(symbol)

  - Used to form full 32-bit addresses in non-PIC code.
  - Represents the high and low 16-bit parts of a symbol's address.
  - Generates R_MIPS_HI16 and R_MIPS_LO16 relocations.

  E.g.,
    lui $t0, %hi(foo)       # $t0 gets the upper 16 bits of foo
    lw  $t1, %lo(foo)($t0)  # Add the lower 16 bits of foo to $t0
                            # and load from the address.

2. %got(symbol)

  - Used to access a symbol's address through GOT.
  - The assembler emits an offset from $gp to the GOT entry for the symbol,
    which the dynamic linker resolves at runtime.
  - Generates an R_MIPS_GOT16 relocation.

  E.g,
    lw $t9, %got(foo)($gp)  # Load address of foo via GOT

3. %pcrel_hi(symbol / %pcrel_lo(symbol)

  - Used in PIC to compute PC-relative addresses.
  - Generates R_MIPS_PCHI16 and R_MIPS_PCLO16 relocations.

  E.g.,
    lui $t0, %pcrel_hi(foo)
    lw  $t1, %pcrel_lo(foo)($t0)

4. %got_page(symbol) / %got_ofst(symbol)

  - Used in PIC to compute GOT-relative addresses more efficiently.
  - %got_page(symbol) gives the GOT entry page base and
    %got_ofst(symbol) gives the offset within that page.
  - Generates R_MIPS_GOT_PAGE and R_MIPS_GOT_OFST relocations.

  E.g.,
    lw $t0, %got_page(foo)($gp)      # $t0 gets the GOT page base for foo
    addiu $t1, $t0, %got_ofst(foo)   # Add the offset to get the address of foo
-------------------------------------------------------------------------------
*/

// load word from GOT: e.g., lw v0, -32696(gp)
value_reg(EA,Reg,EA,"NONE",0,Val,1):-
    instruction(EA,_,_,"LW",_,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,Reg),
    track_register(Reg),
    gp_relative_operand(EA,1,Offset_addr),
    data_word(Offset_addr, 4, Val).

// lui reg3, hi(xxx)
// addiu reg2, reg3, lo(xxx)
// addu reg, reg2, t9 <--- (A)
// Get the value of reg at (A)
// NOTE: This assumes t9 holds the address of the current function, and
//       lui is the first instruction of the current function.
// TODO: Find a way of safely getting the function-entry address for t9.
value_reg_edge(EA,Reg,PrevEA1,Reg,1,as(PrevEA0,number)):-
    split_load_candidate(PrevEA0, PrevEA1, _, "ADDU"), // check on the idiom
    next(PrevEA1,EA),
    instruction_get_operation(EA, "ADDU"),
    instruction_get_dest_op(EA,_,DestOp),
    op_regdirect_contains_reg(DestOp,Reg),
    track_register(Reg).

/**
Instructions with an indirect operand with GP(Global Pointer)-relative address
*/
.decl gp_relative_operand(src:address,index:operand_index, dest:address)

// e.g., lw v0, -32696(gp)
gp_relative_operand(EA,Index,as(GpValue+Offset,address)):-
    instruction_get_op(EA, Index, Op),
    op_indirect(Op,"NONE","GP","NONE",1,Offset,_),
    reg_def_use.def_used(EA_gp_def,"GP",EA,_),
    EA_gp_def != EA,
    value_reg(EA_gp_def,"GP",_,"NONE",_,GpValue,_).

// In case when gp def is not found, use _gp value instead.
// NOTE: This is a hacky trial:
// Assume that at load instructions with the source with gp as base register,
// gp holds the address of _gp (global pointer)
gp_relative_operand(EA,Index,GpValue+as(Offset,address)):-
    instruction(EA,_,_,Operation,Op1,_,0,0,_,_),
    (
        arch.load_operation(Operation),
        Index = 1
        ;
        arch.store_operation(Operation),
        Index = 2
    ),
    op_indirect(Op1,"NONE","GP","NONE",_,Offset,_),
    symbol(GpValue,_,_,_,_,_,_,_,"_gp").

/**
MIPS-specific got_reference using MIPS_GOTSYM and MIPS_LOCAL_GOTNO

The main reason for this is to avoid potential issues in stratification.
Some generic versions of got_reference rely on symbolic_expr, which can
lead to cyclic negation or cyclic aggregation.
*/
.decl got_reference_mips_global(Got_entry:address,Symbol:symbol)
.output got_reference_mips_global

// Global entries
got_reference_mips_global(GotEntry,Symbol):-
    symbol(_,_,_,_,_,_,".dynsym",Index,Symbol),
    dynamic_entry("MIPS_GOTSYM",FirstIndex),
    dynamic_entry("MIPS_LOCAL_GOTNO",NumLocalEntries),
    Index >= FirstIndex,
    loaded_section(Beg,_,".got"),
    GotEntry = Beg + NumLocalEntries*4 + (Index-FirstIndex)*4.

got_reference(GotEntry,Symbol):-
    got_reference_mips_global(GotEntry,Symbol).

// Local entries
got_reference(Got_entry,SymbolName):-
    symbolic_expr(Got_entry,4,SymbolName,0),
    loaded_section(Beg,_,".got"),
    Got_entry >= Beg,
    dynamic_entry("MIPS_LOCAL_GOTNO",NumLocalEntries),
    Got_entry < Beg+4*NumLocalEntries.

.decl hi_load(ea:address, reg:register, upper:number)

// LUI <Register> <Immediate>
// E.g.,
//    1c: lui $t0, 1
// => hi_load(0x1c,T0,1)
hi_load(EA,Reg,Upper):-
    instruction_get_operation(EA, "LUI"),
    instruction_get_op(EA, 1, BaseOp),
    instruction_get_op(EA, 2, RegOp),
    op_immediate(BaseOp, Upper,_),
    op_regdirect_contains_reg(RegOp,Reg).

/**
HI load propagation to recover hi_load value from stack or simple data-flow
*/
.decl hi_load_prop(reg_restore_ea:address, ea:address, reg:register, upper:number, type:symbol)

hi_load_prop(EA,EA,Reg,Upper,"direct"):-
    hi_load(EA,Reg,Upper).

// Recover from stack
hi_load_prop(RegLoadEA,EA,Reg2,Upper,"stack-restore"):-
    hi_load(EA,Reg,Upper),
    reg_def_use.def_used(EA,Reg,RegStoreEA,_),
    stack_def_use.def_used(RegStoreEA,_,RegLoadEA,_,_),
    arch.load(RegLoadEA,_,_,Reg2,_,_,_,_).

// Simple data-flow (e.g., move reg1, reg2)
hi_load_prop(MoveEA,EA,Reg2,Upper,"move"):-
    hi_load(EA,Reg,Upper),
    reg_def_use.def_used(EA,Reg,MoveEA,_),
    arch.move_reg_reg(MoveEA,Reg2,Reg).

// Split-loads -------------------------------------------------------
.decl split_load_candidate(ea_hi:address, ea_lo:address, dest:address, type:symbol)

.decl split_load_point(ea:address, nextea:address, dest:address, type:symbol, point:number, why:symbol)

.decl split_load_conflict(ea:address, nextea:address, dest:address, type:symbol, ea2:address, nextea2:address, dest2:address, type2:symbol)

.decl split_load_total_points(ea:address, nextea:address, dest:address, type:symbol, points:number)

.decl discarded_split_load(ea:address, nextea:address, dest:address, type:symbol, points:number)

// Compute an immediate load performed across two consecutive instructions
.decl split_load(ea:address, nextea:address, dest:address, type:symbol)

// Compute an immediate load/store performed across two separate instructions
.decl split_loadstore(ea:address, nextea:address, dest:address)


// E.g., lui reg, hi(xxx)
//       addiu reg2, reg, lo(xxx)
// or
// E.g., lui reg, hi(xxx)
//       sw reg, n(sp)
//       lw reg2, n(sp)
//       addiu reg3, reg2, lo(xxx)
// reg is store to stack and restored
// or
// E.g., lui reg, hi(xxx)
//       move reg2, reg
//       addiu reg3, reg2, lo(xxx)
split_load_candidate(EA_hi, EA_lo, as(Upper*2^16+Offset,address), "ADDIU") :-
    hi_load_prop(RegRestoreEA,EA_hi,Reg2,Upper,_),
    reg_def_use.def_used(RegRestoreEA,Reg2,EA_lo,_),
    instruction_get_operation(EA_lo, "ADDIU"),
    arch.reg_arithmetic_operation(EA_lo,_,Reg2,_,Offset),
    // Skip in case of split_load_candidate(EA_hi, EA_log, _, "ADDU")
    next(EA_lo,EA),
    // Exclude the PIC case:
    !(
        instruction_get_operation(EA, "ADDU"),
        arch.reg_reg_arithmetic_operation(EA,_,Reg2,"T9",1,0),
        code_in_block(EA_hi, EA_hi)
    ).

// PIC
// E.g., lui reg, hi(xxx)
//       addiu reg2, reg, lo(xxx)
//       addu reg3, reg2, t9
split_load_candidate(EA_hi, EA_lo, as(Upper*2^16+Offset+T9Value,address), "ADDU") :-
    // lui reg, hi(xxx)
    hi_load(EA_hi,Reg,Upper),
    // NOTE: This assumes t9 holds the address of the current function, and
    //       lui is the first instruction of the current function.
    // A sufficient condition is that the lui instruction is
    // at the beginning of a block.
    code_in_block(EA_hi, EA_hi),
    // TODO: Find a way of safely getting the function-entry address for t9.

    reg_def_use.def_used(EA_hi,Reg,EA_lo,_),
    EA_hi != EA_lo,
    // addiu reg2, reg, lo(xxx)
    instruction_get_operation(EA_lo, "ADDIU"),
    arch.reg_arithmetic_operation(EA_lo,Reg2,Reg,_,Offset),

    reg_def_use.def_used(EA_lo,Reg2,EA_addu,_),
    EA_lo != EA_addu,

    // addu reg3, reg2, t9
    instruction_get_operation(EA_addu, "ADDU"),
    arch.reg_reg_arithmetic_operation(EA_addu,_,Reg2,"T9",1,0), // RA too?
    T9Value = as(EA_hi, number).

// E.g., lui reg, hi(xxx)
//       lw/sw reg2, lo(xxx)(reg)
// or
// E.g., lui reg, hi(xxx)
//       sw reg, n(sp)
//       lw reg2, n(sp)
//       lw/sw reg3, lo(xxx)(reg2)
// reg is store to stack and restored
// or
// E.g., lui reg, hi(xxx)
//       move reg2, reg
//       lw/sw reg3, lo(xxx)(reg2)
split_load_candidate(EA_hi, EA_lo, as(Upper*2^16+Offset,address), "LoadStore") :-
    hi_load_prop(RegRestoreEA,EA_hi,Reg,Upper,_),
    reg_def_use.def_used(RegRestoreEA,Reg,EA_lo,_),

    // lw/sw reg3, lo(xxx)(reg2)
    arch.memory_access(_,EA_lo,_,_,_,Reg,"NONE",1,Offset).

split_load_point(EA_hi,EA_lo,Dest_addr,Type,0,"base"):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type).

// Heuristic 1: If the order of hi and lo is backward, it may be
// false-positive.
split_load_point(EA_hi,EA_lo,Dest_addr,Type,-1,"hi-lo-backward"):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type),
    EA_hi > EA_lo.

// Heuristic 2: If the hi and lo are in different functions, it may be
// false-positive. Note that function_entry cannot be used here due to cyclic
// negation. For now, fde_addresses is used instead.
split_load_point(EA_hi,EA_lo,Dest_addr,Type,-5,"maybe-in-different-function"):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type),
    fde_addresses(Begin,_),
    EA_hi < Begin,
    Begin < EA_lo.

// Heuristics 3: ADDU candidates rely on several assumptions.
// If those assumptions are false, we subtract points.

split_load_point(EA_hi,EA_lo,Dest_addr,"ADDU",-1,"t9 cannot have a function pointer"):-
//  lui reg, hi(xxx)
//  addiu reg2, reg, lo(xxx)
    split_load_candidate(EA_hi,EA_lo,Dest_addr,"ADDU"),
    reg_def_use.def_used(EA_lo,Reg,EA_addu,_),
    EA_lo != EA_addu,
    // addu reg3, reg2, t9
    instruction_get_operation(EA_addu, "ADDU"),
    arch.reg_reg_arithmetic_operation(EA_addu,_,Reg,"T9",1,0),
    // t9 cannot be a function pointer if it is
    // the result of a product.
    reg_def_use.def_used(EA_def_t9,"T9",EA_addu,_),
    value_reg(EA_def_t9,"T9",_,_,Mult,_,_), Mult>1.

// TODO: Add more heuristics if needed.

split_load_conflict(EA_hi,EA_lo,Dest_addr,Type,EA_hi2,EA_lo2,Dest_addr2,Type2):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type),
    split_load_candidate(EA_hi2,EA_lo2,Dest_addr2,Type2),
    // Ordering to avoid duplicates
    (
        EA_hi < EA_hi2
        ;
        EA_hi = EA_hi2, EA_lo < EA_lo2
        ;
        EA_hi = EA_hi2, EA_lo = EA_lo2, Dest_addr < Dest_addr2
    ),
    // If two split_loads share either lo or hi or both, and the dest addresses
    // are different, then they conflict.
    (
        EA_lo = EA_lo2
        ;
        EA_hi = EA_hi2
    ),
    Dest_addr != Dest_addr2.


split_load_total_points(EA_hi,EA_lo,Dest_addr,Type,Points):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type),
    Points = sum X:{split_load_point(EA_hi,EA_lo,Dest_addr,Type,X,_)}.

split_load(EA_hi, EA_lo, Dest_addr, Type) :-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,Type),
    Type != "LoadStore",
    !discarded_split_load(EA_hi,EA_lo,Dest_addr,Type,_).

split_loadstore(EA_hi, EA_lo, Dest_addr):-
    split_load_candidate(EA_hi,EA_lo,Dest_addr,"LoadStore"),
    !discarded_split_load(EA_hi,EA_lo,Dest_addr,"LoadStore",_).

discarded_split_load(EA_hi,EA_lo,Dest_addr,Type,Points):-
    split_load_conflict(EA_hi1,EA_lo1,Dest_addr1,Type1,EA_hi2,EA_lo2,Dest_addr2,Type2),
    split_load_total_points(EA_hi1,EA_lo1,Dest_addr1,Type1,Points1),
    split_load_total_points(EA_hi2,EA_lo2,Dest_addr2,Type2,Points2),
    (
        Points1 < Points2,
        EA_hi = EA_hi1,
        EA_lo = EA_lo1,
        Dest_addr = Dest_addr1,
        Type = Type1,
        Points = Points1
        ;
        Points1 > Points2,
        EA_hi = EA_hi2,
        EA_lo = EA_lo2,
        Dest_addr = Dest_addr2,
        Type = Type2,
        Points = Points2
    ).

.decl symbol_type(Addr:address,Type:symbol) inline

symbol_type(Addr,Type):-
    (
        code(Addr), Type="code"
        ;
        data_segment(Begin,End),
        Addr >= Begin, Addr <= End,
        Type = "data"
        ;
        symbol(Addr,_,"FUNC",_,_,_,_,_,_),
        Type = "code"
        ;
        symbol(Addr,_,T,_,_,_,_,_,_),
        T != "FUNC",
        Type = "data"
        ;
        bss_section_limits(Begin,End),
        Addr >= Begin, Addr <= End,
        Type = "data"
    ).

/** ---------------------------------------------------------------------------
got_page / got_fst instructions pairs

EA: Instruction for got_page
Index1: Operand index for got_page
NextEA: Instruction for got_ofst
Index2: Operand index for got_ofst
Reg: Base register in NextEA
Dest_addr: Target symbol address
SymType: Type of target symbol (either "code" or "data")
Got_entry: GOT entry containing page base
Offset: Raw offset in NextEA Index2 operand
Type: Type of got_ofst instruction (either ADDIU or LoadStore)

Use candidate and point system.
-------------------------------------------------------------------------------
*/
.decl base_addr_offset_operand_candidate(EA:address, Index1:operand_index, NextEA:address, Index2:operand_index, Reg:register, Dest_addr:address, SymType:symbol, Got_entry:address, Offset:number, Type:symbol)

.decl base_addr_offset_operand(EA:address, Index1:operand_index, NextEA:address, Index2:operand_index, Dest_addr:address, SymType:symbol, Type:symbol)

.decl base_addr_offset_operand_point(EA:address, Index1:operand_index, NextEA:address, Index2:operand_index, Points:number, Why:symbol)

.decl base_addr_offset_operand_total_points(EA:address, Index1:operand_index, NextEA:address, Index2:operand_index, Points:number)

// ADDIU case:
// e.g., lw $v0, -32696($gp)  <-- v0: MIPS_BASE_ADDRESS
//       addiu $a0, $v0, 2560 <-- 2560: offset from MIPS_BASE_ADDRESS to target L
// ->
//       lw $v0, %got_page(L)($gp)
//       addiu $a0, $v0, %got_ofst(L)
base_addr_offset_operand_candidate(EA,1,NextEA,2,Reg,Dest_addr,SymType,Got_entry,Offset,"ADDIU"):-
    gp_relative_operand(EA,1,Got_entry),

    // Get the page base from GOT and check if it is valid.
    loaded_section(GotBeg,GotEnd,".got"),
    Got_entry >= GotBeg,
    Got_entry < GotEnd,
    value_reg(EA,Reg,_,"NONE",_,BaseAddr,_),
    BaseAddr % 0x1000 = 0, // Page size is at least 0x1000
    !relocation(as(Got_entry,address),_,_,_,_,_,_),
    !got_reference_mips_global(Got_entry,_),
    !(symbol(as(BaseAddr,address),_,_,_,_,_,_,_,_), BaseAddr != 0),

    // E.g., lw $v0, %got_page(L)($gp)
    instruction_get_operation(EA, Operation),
    arch.load_operation(Operation),
    !split_loadstore(_,EA,_),

    (
        reg_def_use.def_used(EA,Reg,NextEA,_),
        EA != NextEA,
        Reg2 = Reg
        ;
        // Recover the page base address from stack:
        // E.g.,
        // lw $v0,%got_page(L)($gp)
        // sw $v0,64($fp)
        // ...
        // lw $v1,64($fp)
        // ...
        // addiu $a3,$v1,%got_ofst(L)
        reg_def_use.def_used(EA,Reg,StoreEA,_),
        stack_def_use.def_used(StoreEA,_,LoadEA,_,_),
        value_reg(LoadEA,Reg2,_,"NONE",_,BaseAddr,_),
        reg_def_use.def_used(LoadEA,Reg2,NextEA,_)
    ),

    // E.g., addiu $a0, $v0, %got_ofst(L)
    arch.reg_arithmetic_operation(NextEA,_,Reg2,_,Offset),
    !split_load(_,NextEA,_,_),

    Dest_addr = as(BaseAddr+Offset,address),
    symbol_type(Dest_addr,SymType).

// LoadStore case:
// e.g., lw $v0, -32696($gp)  <-- v0: MIPS_BASE_ADDRESS
//       lw/sw $a0, 2560($v0) <-- 2560: offset from MIPS_BASE_ADDRESS to target L
// ->
//       lw $v0, %got_page(L)($gp)
//       lw/sw $a0, %got_ofst(L)($a0)
base_addr_offset_operand_candidate(EA,1,NextEA,1,Reg,Dest_addr,SymType,Got_entry,Offset,"LoadStore"):-
    // lw $v0, %got_page(L)($gp)
    gp_relative_operand(EA,1,Got_entry),

    // Get the page base from GOT and check if it is valid.
    loaded_section(GotBeg,GotEnd,".got"),
    Got_entry >= GotBeg,
    Got_entry < GotEnd,
    value_reg(EA,Reg,_,"NONE",_,BaseAddr,_),
    BaseAddr % 0x1000 = 0, // Page size is at least 0x1000
    !relocation(as(Got_entry,address),_,_,_,_,_,_),
    !got_reference_mips_global(Got_entry,_),
    !(symbol(as(BaseAddr,address),_,_,_,_,_,_,_,_), BaseAddr != 0),

    // E.g., lw $v0, %got_page(L)($gp)
    instruction_get_operation(EA, Operation),
    arch.load_operation(Operation),
    !split_loadstore(_,EA,_),

    (
        reg_def_use.def_used(EA,Reg,NextEA,_),
        Reg2 = Reg
        ;
        // Recover the page base address from stack:
        // E.g.,
        // lw $v0,%got_page(L)($gp)
        // sw $v0,64($fp)
        // ...
        // lw $v1,64($fp)
        // ...
        // lw $a3,%got_ofst(L)($v1)
        reg_def_use.def_used(EA,Reg,StoreEA,_),
        stack_def_use.def_used(StoreEA,_,LoadEA,_,_),
        value_reg(LoadEA,Reg2,_,"NONE",_,BaseAddr,_),
        reg_def_use.def_used(LoadEA,Reg2,NextEA,_)
    ),

    // lw/sw $a0, %got_ofst(L)($a0)
    // TODO: In care of "STORE", check if Dest_addr is not read-only.
    arch.memory_access(_,NextEA,_,_,_,Reg2,"NONE",1,Offset),

    Dest_addr = as(BaseAddr+Offset,address),
    symbol_type(Dest_addr,SymType).

// Some examples that should not be got_base/got_ofst pair:
//
// * a loop index:
//       lw $v1, %got(array)($gp)
//   loop:
//       sw $v0, 0($v1)
//       addiu $v1, $v1, 4
//       bne $v0, $a0,.loop
//
// * a loop limit:
//       lw $s0, %got(array)($gp)
//       addiu $s2,$s0,40
//   loop:
//       lw $a2, 0($s0)
//       ...
//       addiu $s0, $s0, 4
//       bne $s0, $s2,.loop
//
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,-3,"possibly loop"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,Reg,_,_,_,_,"ADDIU"),
    reg_def_use.def_used(EA,Reg,OtherEA,_),
    OtherEA != NextEA,
    reg_def_use.def_used(AddEA,Reg,NextEA,_),
    AddEA != EA,
    arch.reg_arithmetic_operation(AddEA,Reg,Reg,_,_).

// Reduce points when the GOT entry does not seem to be MIPS page base
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,-3,"highly likely not page base"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,_,_,Got_entry,_,_),
    address_in_data_refined(Got_entry,SymAddr),
    symbol(SymAddr,_,_,_,_,_,_,_,_).

// Usually offset is non-zero for got_ofst operand
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,-5,"zero offset"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,_,_,_,Offset,_),
    Offset = 0.

// Give points when there are multiple got_ofst instructions that share the same Dest_addr
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,3,"multiple pairs with same dest"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,Reg,Dest_addr,_,Got_entry,Offset,_),
    base_addr_offset_operand_candidate(EA,Index1,OtherEA,_,Reg,Dest_addr,_,Got_entry,Offset,_),
    OtherEA != NextEA,
    Offset != 0.

// Give points when there are multiple got_base instructions that share
// the same got_ofst instruction with the same Dest_addr
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,3,"multiple defs with same base"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,Reg,Dest_addr,_,Got_entry,Offset,_),
    base_addr_offset_operand_candidate(OtherEA,Index1,NextEA,Index2,Reg,Dest_addr,_,Got_entry,Offset,_),
    EA != OtherEA.

// Reduce points when there are multiple defs of the base register and
// some of them are not relevant to got_base/got_ofst
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,-3,"multiple defs with different base"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,Reg,Dest_addr,_,_,_,_),
    reg_def_use.def_used(OtherEA,Reg,NextEA,_),
    OtherEA != EA,
    base_addr_offset_operand_candidate(OtherEA2,Index1,NextEA,Index2,Reg,Dest_addr2,_,_,_,_),
    EA != OtherEA2,
    Dest_addr2 != Dest_addr.

// Give points when Dest_addr is a well-defined function entry
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,3,"possible function entry"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,Dest_addr,_,_,_,_),
    function_inference.function_entry_initial(Dest_addr).

// Reduce points when non-data Dest_addr is not aligned
base_addr_offset_operand_point(EA,Index1,NextEA,Index2,-2,"possibly not aligned code"):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,Dest_addr,_,_,_,_),
    Dest_addr % 4 != 0,
    0 = count : {data_segment(Beg,End), Dest_addr >= Beg, Dest_addr <= End}.

base_addr_offset_operand_total_points(EA,Index1,NextEA,Index2,Points):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,_,_,_,_,_),
    (
        Points = sum X:{base_addr_offset_operand_point(EA,Index1,NextEA,Index2,X,_)}
        ;
        !base_addr_offset_operand_point(EA,Index1,NextEA,Index2,_,_), Points = 0
    ).

.decl mips_page_base_in_got(Got_entry:address)
.output mips_page_base_in_got

mips_page_base_in_got(Got_entry),
base_addr_offset_operand(EA,Index1,NextEA,Index2,Dest_addr,SymType,Type):-
    base_addr_offset_operand_candidate(EA,Index1,NextEA,Index2,_,Dest_addr,SymType,Got_entry,_,Type),
    base_addr_offset_operand_total_points(EA,Index1,NextEA,Index2,Points),
    Points >= 0.

symbolic_operand_attribute(EA_ofst,Index_ofst,"GOT"),
symbolic_operand_attribute(EA_ofst,Index_ofst,"OFST"),
symbolic_operand_attribute(EA,Index,"GOT"),
symbolic_operand_attribute(EA,Index,"PAGE"):-
    base_addr_offset_operand(EA,Index,EA_ofst,Index_ofst,Dest_addr,_,_),
    (
        symbolic_expr(EA,_,SymbolName,_),
        symbol(0,_,_,_,_,_,_,_,SymbolName),
        UNUSED(Dest_addr)
        ;
        symbol(Dest_addr,_,_,_,_,_,_,_,_)
        ;
        inferred_symbol(Dest_addr,_,_,_,_,"Beg")
        ;
        inferred_symbol(Moved_addr,_,_,_,_,"Beg"),
        moved_label(EA,Index,Dest_addr,Moved_addr)
    ).

symbolic_operand_attribute(EA, 1, "PCREL"):-
    binary_type("DYN"),
    (
        split_load(EA,_,_,_)
        ;
        split_loadstore(EA,_,_)
    ),
    0 = count : {
        split_load(EA,_,Dest_addr,_),
        symbol(Dest_addr,_,_,_,_,_,_,_,"_gp")
    }.

symbolic_operand_attribute(EA, Index, "PCREL"):-
    binary_type("DYN"),
    (
        split_load(_,EA,_,_), Index = 2
        ;
        split_loadstore(_,EA,_), Index = 1
    ),
    0 = count : {
        split_load(_,EA,Dest_addr,_),
        symbol(Dest_addr,_,_,_,_,_,_,_,"_gp")
    }.

symbolic_operand_attribute(EA, 1, "HI"):-
    (
        split_load(EA,_,Dest_addr,_);
        split_loadstore(EA,_,Dest_addr)
    ),
    match_symbol_dest_addr(Dest_addr).

symbolic_operand_attribute(EA, Index, "LO"):-
    (
        split_load(_,EA,Dest_addr,_),
        Index = 2
        ;
        split_loadstore(_,EA,Dest_addr),
        Index = 1
    ),
    match_symbol_dest_addr(Dest_addr).

// E.g., lw t9, %got(puts)(gp)
symbolic_operand_attribute(EA,Index,"GOT"):-
    symbolic_operand_mips_candidate(EA,Index,Got_entry),
    got_reference(Got_entry,SymName),
    !mips_page_base_in_got(Got_entry),
    (
        symbol(_,_,_,_,_,_,_,_,SymName)
        ;
        inferred_symbol(_,_,Scope,_,_,_)
    ).

// Special handling of _IO_stdin_used
symbolic_operand_attribute(EA,Index,"GOT"),
symbolic_expr(EA,Size,Symbol,0):-
    gp_relative_operand(EA,Index,Got_entry),
    Symbol = "_IO_stdin_used",
    got_reference_mips_global(Got_entry,Symbol),
    arch.pointer_size(Size).

.decl match_symbol_dest_addr(Dest_addr:address) inline

match_symbol_dest_addr(Dest_addr):-
    (
        code(Dest_addr)
        ;
        function_inference.function_entry(Dest_addr)
        ;
        data_segment(Begin,End),
        Dest_addr >= Begin, Dest_addr <= End
        ;
        symbol(Dest_addr,_,_,_,_,_,_,_,_)
        ;
        got_reference(Dest_addr,_)
    ).

.decl symbolic_operand_mips_candidate(ea:address,index:operand_index,dest:address)

symbolic_operand_mips_candidate(EA,Index,Dest):-
    gp_relative_operand(EA,Index,Dest).

symbolic_operand_mips_candidate(EA,1,Dest):-
    split_load(EA,_,Dest,_).

symbolic_operand_mips_candidate(EA,2,Dest):-
    split_load(_,EA,Dest,_).

symbolic_operand_mips_candidate(EA,1,Dest):-
    split_loadstore(EA,_,Dest).

symbolic_operand_mips_candidate(EA,1,Dest):-
    split_loadstore(_,EA,Dest).

symbol_minus_symbol(EA,4,EA,GP_addr,1,0):-
    split_load(EA,_,_,"ADDU"),
    symbol(GP_addr,_,_,_,_,_,_,_,"_gp").

symbol_minus_symbol(EA,4,PrevEA,GP_addr,1,0):-
    split_load(PrevEA,EA,_,"ADDU"),
    symbol(GP_addr,_,_,_,_,_,_,_,"_gp").

symbolic_operand_candidate(EA,Index,Dest_addr,SymType):-
    base_addr_offset_operand(EA,Index,_,_,Dest_addr,SymType,_).

symbolic_operand_candidate(EA,Index,Dest_addr,SymType):-
    base_addr_offset_operand(_,_,EA,Index,Dest_addr,SymType,_).

symbolic_operand_candidate(EA,Op_index,Dest_addr,Type):-
    code(EA),
    symbolic_operand_mips_candidate(EA,Op_index,Dest_addr),
    !tls_relative_operand_mips(EA,_,_,_,Dest_addr,_),
    !base_addr_offset_operand(EA,_,_,_,_,_,_),
    symbol_type(Dest_addr,Type).

symbolic_operand_point(EA,Op_index,1,"lookup-got"):-
    symbolic_operand_candidate(EA,Op_index,_,_),
    instruction_get_op(EA,Op_index,Op),
    op_indirect(Op,"NONE","GP","NONE",1,_,_),
    def_used_for_address(EA,_,_).

data_object_point(EA,Pt_size,"symbol",-5,"mips_base_address"):-
    mips_page_base_in_got(EA),
    arch.pointer_size(Pt_size).

/** ---------------------------------------------------------------------------
MIPS-specific inferred_symbol:

The MIPS assembler requires any symbol referenced by a GOT-related relocation
to be global; otherwise, assembly fails (e.g., with an error that local symbols
cannot use %got).

However, in a fully linked shared object, symbols originally accessed via
%got(sym) may appear as *local* in the ELF symbol table. This happens because
the linker performs symbol binding reduction -- localizing symbols that are not
exported -- even if they were originally global during assembly and relocation
processing.

As a result, some GOT entries correspond to symbols that now appear local, and
reassembling such code would fail because the assembler rejects %got references
to local symbols.

This discrepancy arises from the difference between what the assembler allows
and what the linker produces.

To resolve this issue, we create a new inferred symbol with GLOBAL binding and
HIDDEN visibility for such cases.
-------------------------------------------------------------------------------
*/
.decl inferred_symbol_mips(EA:address,SymbolName:symbol,Scope:symbol,Visibility:symbol,Type:symbol,Pos:symbol_position)
.output inferred_symbol_mips

// Symbols accessed via GOT need to be defined as GLOBAL.
inferred_symbol_mips(EA,SymbolName,"GLOBAL","HIDDEN","NONE","Beg"):-
    labeled_ea(EA),
    SymbolName = cat(".L_",@to_string_hex(EA)),
    (
        // lw $a0,%got_page(.L_xxxx)($gp)
        symbolic_operand(_,_,EA,_),
        base_addr_offset_operand(_,_,_,_,EA,_,_)
        ;
        // GOT entry targets
        loaded_section(GotBeg,GotEnd,".got"),
        Got_entry >= GotBeg, Got_entry < GotEnd,
        aligned_address_in_data(Got_entry,EA),
        !mips_page_base_in_got(EA),
        (
            symbol(EA,_,_,"LOCAL",_,_,_,_,_)
            ;
            symbol(EA,_,_,"GLOBAL",_,_,_,_,AmbiguousSym),
            ambiguous_symbol(AmbiguousSym)
            ;
            !symbol(EA,_,_,_,_,_,_,_,_)
        )
    ),
    !inferred_special_symbol(EA,_,_,_,_,_).

inferred_symbol_mips(EA,SymbolName,"LOCAL","DEFAULT","NONE","Beg"):-
    labeled_ea(EA),
    !symbol_score(EA,_,_,"Beg",_),
    !best_func_symbol(EA,_),
    !inferred_special_symbol(EA,_,_,_,_,_),
    SymbolName = cat(".L_",@to_string_hex(EA)).

// GLOBAL is preferred over LOCAL or WEAK
inferred_symbol(EA,SymbolName,"GLOBAL",Visibility,Type,"Beg"):-
    inferred_symbol_mips(EA,SymbolName,"GLOBAL",Visibility,Type,"Beg").

inferred_symbol(EA,SymbolName,Scope,Visibility,Type,"Beg"):-
    inferred_symbol_mips(EA,SymbolName,Scope,Visibility,Type,"Beg"),
    0 = count : {
        inferred_symbol_mips(EA,SymbolName,"GLOBAL",_,Type,"Beg")
    }.

// GLOBAL/HIDDEN symbols, for the reason described above, take precedence over
// those provided by the symbol-core system.
best_symexpr_symbol(EA,SymName,Pos):-
    symbol_score(EA,SymbolName,_,Pos,Score),
    Score = max S: {symbol_score(EA,_,_,Pos,S)},
    (
        // If the original symbol is either GLOBAL or WEAK, choose it.
        symbol(EA,_,_,"GLOBAL",_,_,_,_,SymbolName),
        SymbolName != "",
        SymName = SymbolName
        ;
        symbol(EA,_,_,"WEAK",_,_,_,_,SymbolName),
        SymbolName != "",
        SymName = SymbolName
        ;
        // If the original symbol is _gp, choose it.
        symbol(EA,_,_,_,_,_,_,_,SymbolName),
        SymbolName = "_gp",
        SymName = SymbolName
        ;
        // If the original symbol is LOCAL and there is an inferred symbol,
        // choose it.
        symbol(EA,_,_,"LOCAL",_,_,_,_,SymbolName),
        inferred_symbol_mips(EA,SymbolName2,_,_,_,Pos),
        SymName = SymbolName2
        ;
        // If there was not symbol at the address, choose the inferred symbol.
        !symbol(EA,_,_,_,_,_,_,_,_),
        inferred_symbol_mips(EA,SymbolName2,_,_,_,Pos),
        SymName = SymbolName2
        ;
        // If there is not inferred symbol, choose the original symbol.
        symbol(EA,_,_,"LOCAL",_,_,_,_,SymName),
        SymName != "",
        !inferred_symbol_mips(EA,_,_,_,_,Pos)
    ).

// If there is no symbol produced by the symbol-score system,
// choose the inferred symbol.
best_symexpr_symbol(EA,SymbolName,"Beg"):-
    inferred_symbol_mips(EA,SymbolName,_,_,_,"Beg"),
    !symbol_score(EA,_,_,"Beg",_).


.decl mips_stubs_section(name:symbol)

mips_stubs_section(".MIPS.stubs").

.decl mips_stubs_entry(Block:address,Function:symbol)

mips_stubs_entry(Block,Function):-
    mips_stubs_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,
    // Reuse the definition of plt_entry_candidate since the pattern
    // is the same.
    plt_entry_candidate(EA,GotIndex),
    symbol(_,_,_,_,_,_, ".dynsym",GotIndex,Function),
    code_in_refined_block(EA,Block).

.decl plt_entry_candidate(EA:address,GotIndex:unsigned)

// Pattern-matching.1:
//   lw $t9, _GLOBAL_OFFSET_TABLE_($gp)
//   move $t7,$ra
//   jalr $t9
//   addiu $t8,$zero,N
// where N is the index of the target in the _GLOBAL_OFFSET_TABLE_.
plt_entry_candidate(EA,as(GotIndex,unsigned)):-
    // lw $t9, _GLOBAL_OFFSET_TABLE_($gp)
    instruction(PrevEA2,_,_,"LW",Op1,Op2,0,0,_,_),
    op_regdirect_contains_reg(Op2,"T9"),
    op_indirect(Op1,"NONE","GP","NONE",_,Offset,_),
    symbol(GpValue,_,_,_,_,_,_,_,"_gp"),
    loaded_section(GotBeg,_,".got"),
    GotBeg = GpValue+as(Offset,address),

    next(PrevEA2, PrevEA),

    // move $t7,$ra
    instruction(PrevEA,_,_,"MOVE",Op1_2,Op2_2,0,0,_,_),
    op_regdirect_contains_reg(Op2_2,"T7"),
    op_regdirect_contains_reg(Op1_2,"RA"),

    next(PrevEA, EA),

    // jalr $t9
    instruction(EA,_,_,"JALR",Op1_3,0,0,0,_,_),
    op_regdirect_contains_reg(Op1_3,"T9"),

    next(EA, NextEA),

    // addiu $t8,$zero,N
    instruction(NextEA,_,_,"ADDIU",Op1_4,Op2_4,Op3_4,0,_,_),
    op_regdirect_contains_reg(Op3_4,"T8"),
    op_regdirect_contains_reg(Op1_4,"ZERO"),
    op_immediate(Op2_4,GotIndex,_).

plt_entry(EA,Function):-
    plt_entry_candidate(EA,GotIndex),
    symbol(_,_,_,_,_,_, ".dynsym",GotIndex,Function).

// Pattern-matching.2:
// E.g.,
//   EA:       lui $t7,%hi(.L_XXXX)
//   NextEA:   lw $t9,%lo(.L_XXXX)($t7)
//   EA_JR:    jr $t9
//   EA_ADDIU: addiu $t8,$t7,%lo(.L_XXXX) // delay-slot
// or
//   EA:       lui $t7,%hi(.L_XXXX)
//   NextEA:   lw $t9,%lo(.L_XXXX)($t7)
//   EA_ADDIU: addiu $t8,$t7,%lo(.L_XXXX)
//   EA_JR:    jr $t9                     // no delay-slot
//
// NOTE: Cases of no delay-slot were observed
plt_entry(EA_JR,Function):-
    plt_section(SecName),
    loaded_section(Beg,End,SecName),
    EA >= Beg,
    EA < End,

    next(EA,NextEA),

    // NOTE: We can't use split_load_candidate here due to cyclic negation
    hi_load(EA,Reg,Upper),
    instruction_get_operation(NextEA, Operation),
    arch.load_operation(Operation),
    instruction_get_src_op(NextEA,_,Op),
    op_indirect_mapped(Op,"NONE",Reg,"NONE",_,Offset,_),
    Dest_addr = as(Upper*2^16+Offset,address),

    next(NextEA,NextEA2),
    next(NextEA2,NextEA3),

    (
        EA_JR = NextEA2, EA_ADDIU = NextEA3 // delay-slot
        ;
        EA_JR = NextEA3, EA_ADDIU = NextEA2 // no delay-slot
    ),

    // jr $t9
    instruction(EA_JR,_,_,"JR",TargetOp,0,0,0,_,_),
    op_regdirect_contains_reg(TargetOp,"T9"),

    instruction_get_operation(EA_ADDIU, "ADDIU"),
    arch.reg_arithmetic_operation(EA_ADDIU,_,Reg,_,Offset),

    relocation(Dest_addr,_,Function,_,_,_,_).


// FIXME: This rule might be subsumed by the general rules
// lui reg1, hi(XXX)
// lw reg2, lo(XXX)(reg1)
// jr reg2
resolved_transfer(EA,DestAddr,"branch"):-
    code(EA),
    instruction(EA,_,_,"JR",Op,0,0,0,_,_),
    op_regdirect_contains_reg(Op,Reg),
    reg_def_use.def_used(EA_def,Reg,EA,_),
    instruction_get_operation(EA_def, "LW"),
    split_load_candidate(_,EA_def,Addr,_),
    symbolic_data(Addr,4,Dest),
    DestAddr = as(Dest,address),
    code(DestAddr).

// These symbols point to stubs into the .MIPS.stubs section.
// we use `abi_intrinsic` to rename them and let the compiler add new stubs.
abi_intrinsic(SymAddr,Symbol):-
    mips_stubs_entry(_,Symbol),
    symbol(SymAddr,_,_,_,_,_,".dynsym",_,Symbol).

abi_intrinsic(SymAddr,Sym):-
    symbol(SymAddr,_,_,_,_,_,_,_,Sym),
    (
        Sym = "_gp";
        Sym = "__RLD_MAP";
        Sym = "_IO_stdin_used"
    ).

abi_intrinsic(SymAddr,Sym):-
    plt_entry(_,Sym),
    symbol(SymAddr,_,_,_,_,_,_,_,Sym).

/**
Some relocations may reference labels inside the body of a function,
not just function entry points.
Log any symbolic operands with attribute whose target lies in the middle of function.
*/
.decl mips_attribute_target_to_mid_function(EA:address, Dest_addr:address, Attribute:symbol)
.output mips_attribute_target_to_mid_function

mips_attribute_target_to_mid_function(EA,Dest_addr,Attribute):-
    symbolic_operand_attribute(EA,_,Attribute),
    symbolic_operand(EA,_,Dest_addr,_),
    code(Dest_addr),
    !function_inference.function_entry(Dest_addr).
