//===- arm32_ci_heuristics.dl ------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019-2022 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
ARM32 architecture-specific rules for code inference.
*/

//////////////////////////////////////////////////////////////////////////
// invalid instructions

// doubleword operations require an even,odd pair of registers, e.g., r2,r3
// Rt2 isn't really encoded in the instruction, it's derived from Rt, so we
// just need to ensure Rt is even.
invalid(EA,"arm: doubleword op Rt is odd"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,Offset), // memory access for Rt
    arch.memory_access(_,EA,_,_,_,_,_,_,Offset2), // memory access for Rt2
    Offset < Offset2,
    instruction_get_operation(EA,Operation),
    OperationRoot = substr(Operation,0,4),
    (
        OperationRoot = "LDRD";
        OperationRoot = "STRD"
    ),
    (EA band 1) = 0, // ARM mode only
    (
        // If Rt is odd, the instruction is invalid.
        arch.reg_index(Rt,Index),
        (Index band 1) = 1
        ;
        // If Rt is LR, the instruction is invalid.
        Rt = "LR"
    ).

// For T32 instructions, you must not specify SP or PC for either Rt or Rt2.
// LDRD Rt, Rt2, [Rn]
// LDRD Rt, Rt2, [Rn], #offset
invalid(EA,"thumb: doubleword op registers invalid"):-
    arch.memory_access(_,EA,_,_,Rt,_,_,_,_),
    (EA band 1) = 1, // Thumb mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    (
        Rt = "SP";
        Rt = "PC"
    ).

// Applies to all of STR,LDR,STRD,LDRD
invalid(EA,"arm: pre/post-index disallows Rt[2] eq Rn"):-
    // For LDRD operations, there will be an 'arch.memory_access' for each of
    // Rt and Rt2, so this rule will check both for conflict with Rn.
    arch.memory_access(_,EA,_,_,Rt,Rn,_,_,_),
    Rt = Rn,
    instruction_writeback(EA),
    instruction_get_operation(EA,Operation),
    BaseOperation = substr(Operation,0,3),
    (
        BaseOperation = "LDR";
        BaseOperation = "STR"
    ).

// Rm must be different from Rt and Rt2 in LDRD instructions.
// LDRD{cond} Rt, Rt2, [Rn], ±Rm
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]
// LDRD{cond} Rt, Rt2, [Rn, ±Rm]!
invalid(EA,"arm: doubleword rm/rt conflict"):-
    (
        arch.memory_access(_,EA,_,_,Rt,_,Rm,_,_), Rm != "NONE";
        // Post-index form: Rm is not part of the memory access, since it is
        // only incremented afterward.
        arch.memory_access(_,EA,_,_,Rt,Rn,"NONE",_,_),
        arch.reg_reg_arithmetic_operation(EA,Rn,Rn,Rm,_,0)
    ),
    (EA band 1) = 0, // ARM mode only
    instruction_get_operation(EA,Operation),
    substr(Operation,0,4) = "LDRD",
    // For LDRD operations, there will be an 'arch.memory_access' for each of
    // Rt and Rt2, so this rule will check both for conflict with Rm.
    Rt = Rm.

invalid(EA,"arm: pc is not allowed as dest"):-
    instruction_get_operation(EA,Operation),
    (
        contains("AND",Operation);
        contains("BIC",Operation);
        contains("MOVT",Operation);
        contains("MOVW",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: pc is not allowed as src"):-
    instruction_get_operation(EA,Operation),
    (
        // ldm pc, {...}
        contains("LDM",Operation)
        ;
        // mov sp, pc
        contains("MOV",Operation),
        instruction_get_dest_op(EA,_,DestOp),
        op_regdirect_contains_reg(DestOp,SP),
        arch.stack_pointer(SP)
    ),
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: sp is not allowed in AND"):-
    instruction_get_operation(EA,Operation),
    substr(Operation,0,3) = "AND",
    instruction_get_src_op(EA,_,Op),
    op_regdirect_contains_reg(Op,SP),
    arch.stack_pointer(SP).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

invalid(EA,"arm: pc cannot be used as index register"):-
    instruction_get_op(EA,_,Op),
    op_indirect_mapped(Op,_,_,PC,_,_,_),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid mul operand (pc)"):-
    instruction_get_operation(EA,Operation),
    contains("MUL",Operation),
    instruction_get_op(EA,_,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.pc_reg(Reg).

invalid(EA,"arm: deprecated bx"):-
    instruction_get_operation(EA,"BX"),
    instruction_get_op(EA,1,Op),
    op_regdirect_contains_reg(Op,Reg),
    arch.stack_pointer(Reg).

// The following instructions do not allow PC as the destination register.
invalid(EA,"arm: invalid pc"):-
    instruction_get_operation(EA,Operation),
    (
        Operation = "MLAHS";
        Operation = "MLASHS";
        contains("LDRB",Operation);
        contains("LDRSB",Operation);
        contains("LDRH",Operation);
        contains("LDRSH",Operation)
    ),
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA,"arm: invalid arithmetic instruction with suffix s"):-
    instruction_get_operation(EA,Operation),
    strlen(Operation) >= 4,
    substr(Operation,0,3) = OP,
    (
        OP = "ADD"; OP = "SUB"; OP = "RSB";
        OP = "ADC"; OP = "SBC"; OP = "RSC"
    ),
    substr(Operation,3,1) = "S",
    instruction_get_dest_op(EA,_,Op),
    op_regdirect_contains_reg(Op,PC),
    arch.pc_reg(PC).

invalid(EA, "arm: invalid stm/ldm"):-
    instruction(EA,Size,_,Operation,RegListOp,RegOp,0,_,_,_),
    BaseOperation = substr(Operation,0,3),
    (
         BaseOperation = "STM";
         BaseOperation = "LDM"
    ),
    instruction_writeback(EA),
    op_regdirect_contains_reg(RegOp,Reg),
    op_regdirect_contains_reg(RegListOp,Reg),
    (
        // Reg is not allowed in the reglist in 32-bit Thumb instructions
        EA band 1 = 1,
        Size = 4
        ;
        // Reg is not allowed in the reglist in LDM instructions (all modes)
        BaseOperation = "LDM",
        UNUSED(Size)
    ).


/**
Assign ARM version names to their generation number

e.g., "v7E_M" -> 7
*/
.decl arm_ver_order(Name:symbol,VersionID:unsigned)

arm_ver_order("Pre_v4", 3).
arm_ver_order("v4", 4).
arm_ver_order("v4T", 4).
arm_ver_order("v5T", 5).
arm_ver_order("v5TE", 5).
arm_ver_order("v5TEJ", 5).
arm_ver_order("v6", 6).
arm_ver_order("v6KZ", 6).
arm_ver_order("v6_M", 6).
arm_ver_order("v6S_M", 6).
arm_ver_order("v7", 7).
arm_ver_order("v7E_M", 7).
arm_ver_order("v8_A", 8).
arm_ver_order("v8_R", 8).
arm_ver_order("v8_M_Base", 8).
arm_ver_order("v8_M_Main", 8).
arm_ver_order("v8_1_M_Main", 8).
arm_ver_order("v9", 9).

invalid(EA,"hlt: min v8"):-
    arch_info("Arch",Version),
    arm_ver_order(Version,VerID),
    VerID < 8,
    instruction_get_operation(EA,"HLT").

invalid(EA,"writeback to PC"):-
    instruction_writeback(EA),
    instruction_get_op(EA,_,Op),
    op_indirect(Op,_,PCIn,_,_,_,_),
    reg_map(PCIn,PC),
    arch.pc_reg(PC).

//////////////////////////////////////////////////////////////////////////
// basic targets

basic_target(Val+1):-
    defined_symbol(Val,_,_,_,_,_,_,_,Name),
    thumb_sym(Name).

basic_target(Val):-
    defined_symbol(Val,_,_,_,_,_,_,_,Name),
    !thumb_sym(Name),
    !data_sym(Name).

/**
In some cases, a function has no explicit caller or does not have a
corresponding function symbol.
In order to initially recognize it as a code block in such cases,
treat "push {lr}", which is a typical instruction that starts a function,
as a basic target.
E.g., asterisk

FIXME: This is a heuristic: i.e., we can still miss blocks if the function
starts with other instructions. It is better to make the initial candidate
blocks by brute force, and refine them later with heuristics.
TODO: One option could be to re-define `after_end` for arm.
The current definition skips through nops only.
We could change its behavior for arm to skip also through locations that
have no instruction at all. This should allow it to skip through literal pools.
*/
basic_target(EA):-
    instruction_get_operation(EA,Operation),
    contains("PUSH",Operation),
    instruction_get_src_op(EA,_,RegBitFieldOp),
    op_regdirect_contains_reg(RegBitFieldOp,"LR").

/**
ldr Reg1, .L0
add Reg2, Reg1, pc

Uses `straight_line_def_used`, which is a weaker version of `def_used` that can
be used before code inference.
*/
.decl init_ldr_add_pc(EA_ldr:address,Size:unsigned,Reg1:register,LitPoolAddr:address,EA_add_pc:address,Reg2:register)

init_ldr_add_pc(EA_ldr,Size,Reg1,LitPoolAddr,EA_add_pc,Reg2):-
    litpool_ref(EA_ldr,EA_ldr,LitPoolAddr,0,Size,_),
    instruction_get_operation(EA_ldr,Operation),
    arch.load_operation(Operation),
    straight_line_def_used(EA_ldr,Reg1,EA_add_pc,_),
    arch.reg_reg_arithmetic_operation(EA_add_pc,Reg2,Reg1,PC,1,0),
    arch.pc_reg(PC).

/**
A weaker version of `cinf_symbol_minus_symbol_candidate_arm` that can be used
before code inference.
see the comment of `cinf_symbol_minus_symbol_candidate_arm`.
*/
.decl init_symbol_minus_symbol_candidate_arm(EA:address,Size:unsigned,Symbol1:address,Symbol2:address,Scale:unsigned,Offset:number)

init_symbol_minus_symbol_candidate_arm(Addr,Size,EA_add_pc,Dest,Scale,Offset):-
    init_ldr_add_pc(_,Size,Reg,Addr,EA_add_pc,Reg),
    symbol_minus_symbol_candidate_arm(Addr,Size,EA_add_pc,Dest,Scale,Offset).

/**
When a block address is referenced only by a symbol-symbol literal pool, make
sure the target is treated as a separate block by adding it as basic_target.
E.g., asterisk: 0x353e1
*/
basic_target(EA):-
    init_symbol_minus_symbol_candidate_arm(_,_,_,EA,_,_).

// Create a target only if there's only one possible instruction mode at the
// address. Creating both as potential targets creates too many false
// positives.
basic_target(Inst):-
    arm_exidx_entry(Start,_),
    arch.instruction_at(Start,Inst),
    invalid(Inst bxor 1,_).

// Always split blocks at arm_exidx_entry.
block_limit(Inst):-
    arm_exidx_entry(Start,_),
    arch.instruction_at(Start,Inst).

//////////////////////////////////////////////////////////////////////////
// known/impossible blocks

// exidx metadata doesn't set the low bit to indicate Thumb, so we can only use
// it as a source of known block if the address isn't both an ARM and Thumb
// block.
known_block(Block,"code",BlockEnd - BlockBeg,".ARM.exidx"):-
    arm_exidx_entry(Start,0),
    arch.instruction_at(Start,Block),
    block_candidate_boundaries(Block,"code",BlockBeg,BlockEnd),
    !block_candidate_boundaries(Block bxor 1,"code",_,_).

// a block that overlaps both potential .ARM.exidx functions must not exist.
impossible_block(Other,"data",DataEnd - DataStart,"overlaps .ARM.exidx"):-
    arm_exidx_entry(Start,0),
    BlockArm = Start,
    BlockThumb = Start bor 1,
    block_candidate_boundaries(BlockArm,"code",_,EndArm),
    block_candidate_boundaries(BlockThumb,"code",_,EndThumb),
    block_candidate_boundaries(Other,"data",DataStart,DataEnd),
    DataStart < min(EndArm, EndThumb),
    Start < DataEnd.

// Mapping symbols yield known blocks.
known_block(Block,"code",Size,"$a"):-
    arm_sym(Name),
    defined_symbol(Block,_,_,_,_,_,_,_,Name),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

known_block(Block,"code",Size,"$t"):-
    thumb_sym(Name),
    defined_symbol(SymAddr,_,_,_,_,_,_,_,Name),
    Block = SymAddr bor 1,
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

impossible_block(Block,"code",End-Start,"Overlaps $d symbol"):-
    defined_symbol(EA,0,_,_,_,_,_,_,"$d"),
    block_candidate_boundaries(Block,"code",Start,End),
    Start <= EA,
    EA < End.

// TODO: are there more relocation types that we can use as known blocks?
known_block(Block,"code",Size,"arm: THM_CALL relocation"):-
    binary_type("REL"),
    code_in_block_candidate_refined(EA,Block),
    arch.call(EA,_),
    AlignedEA = EA - (EA band 1),
    relocation(AlignedEA,"THM_CALL",_,_,_,_,_),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start.

//////////////////////////////////////////////////////////////////////////
// literal pools

litpool_ref(EA,EA,RefAddr,0,Size,OpIndex):-
    !invalid(EA,_),
    arch.simple_data_load(EA,RefAddr,Size),
    instruction_memory_access_size(EA,OpIndex,Size).

litpool_ref(EA,EA_load,RefAddr,Offset,Size,OpIndex):-
    arch.pc_relative_addr(EA,_,RefAddr),
    composite_data_access(EA,EA_load,Data,Size),
    Offset = Data - RefAddr,
    !invalid(EA,_),
    !invalid(EA_load,_),
    instruction_immediate_offset(EA,OpIndex,_,_).

/**
Addresses where the propagation of indefinite data blocks should be limited.

Similar to (and a superset of) block_limit for code blocks.
*/
.decl data_block_limit(Limit:address)

data_block_limit(Limit):-
    block_limit(Inst),
    // Block limit gives in instruction identifier; convert to the aligned
    // instruction start address.
    arch.instruction_at(Limit,Inst).

data_block_limit(Limit):-
    litpool_ref(_,_,RefAddr,Offset,_,_),
    Limit = RefAddr + Offset.

/**
References to potential litpools with indeterminate sizes.
*/
.decl indefinite_litpool_ref(Start:address,Size:unsigned)


// If there's no known use of a pc-relative register,
// it may be a reference to data that is getting passed to a function.
indefinite_litpool_ref(RefAddr,Size):-
    arch.pc_relative_addr(EA,_,RefAddr),
    code_in_block_candidate(EA,_),
    !composite_data_access(EA,_,_,_),
    !ascii_string(RefAddr,_),
    NextLimit = min Limit : {
        data_block_limit(Limit),
        Limit > RefAddr
    },
    Size = NextLimit - RefAddr.

data_block_candidate(RefAddr,Size):-
    indefinite_litpool_ref(RefAddr,Size).

/*
Collect all literal pool addresses computed from `litpool_ref`s.
*/
.decl litpool_boundaries(BegAddr:address,EndAddr:address)

litpool_boundaries(LitPoolAddr,LitPoolAddr+Size):-
    litpool_ref(_,_,RefAddr,Offset,Size,_),
    LitPoolAddr = RefAddr+Offset.

/**
Check if the given block overlaps with a possible literal pool.
*/
.decl overlap_with_litpool(Block:address)

overlap_with_litpool(Block):-
    block_overlap(Block,"code",_,Block2,"data",LitPoolSize),
    litpool_ref(EA,_,Block2,_,LitPoolSize,_),
    code_in_block_candidate_refined(EA,Block3),
    !block_overlap(Block3,"code",_,_,"data",_).

/**
Confidence level for each literal pool
*/
.decl litpool_confidence(EARef:address, LitPoolAddr:address, Reason:symbol)

/**
ADR/LDM pair loads multiple data from literal pool.
Create `data_block_candidate` accordingly.
E.g.,
adr r2, .L_xxx
ldm r2, { r2, r3 }
.L_xxx: 8 byte data
*/
litpool_confidence(EA,LitPoolAddr,Heuristic):-
    arch.pc_relative_addr(EA,Reg,LitPoolAddr),
    straight_line_def_used(EA,Reg,EA_ldm,_),
    instruction_get_operation(EA_ldm,Operation),
    contains("LDM",Operation),
    code_in_block_candidate_refined(EA,Block),
    (
        unresolved_block(Block,"code",_),
        Heuristic = "litpool ref block: adr/ldm unresolved"
        ;
        !unresolved_block(Block,"code",_),
        !impossible_block(Block,"code",_,_),
        Heuristic = "litpool ref block: adr/ldm"
    ).

/**
Give more points in case of ldr/ldrd or adr/ldrd, which is likely a valid
instruction sequence.
*/
litpool_confidence(EA,LitPoolAddr,Heuristic):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    straight_line_def_used(EA_ldr,_,EA_ldrd,_),
    instruction_get_operation(EA_ldrd,Operation),
    contains("LDRD",Operation),
    !arch.dangling_thumb_instr(EA),
    code_in_block_candidate_refined(EA,Block),
    (
        unresolved_block(Block,"code",_),
        Heuristic = "litpool ref block: ldr/ldrd unresolved"
        ;
        !unresolved_block(Block,"code",_),
        !impossible_block(Block,"code",_,_),
        Heuristic = "litpool ref block: ldr/ldrd"
    ).


/**
If the ref block is not overlapping, it is likely a true literal pool.
*/
litpool_confidence(EA,LitPoolAddr,"litpool ref block: ref by non-overlapping block"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    !unresolved_block(Block,"code",_),
    !impossible_block(Block,"code",_,_).

/**
Even if the ref block is overlapping, if the literal pool block is not
overlapping, give 1 point.
*/
litpool_confidence(EA,LitPoolAddr,"litpool ref block: not overlapping"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,LitPoolSize,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    !code_in_block_candidate_refined(LitPoolAddr+(EA band 1),_),
    !unresolved_block(LitPoolAddr,"data",LitPoolSize),
    !impossible_block(LitPoolAddr,"data",LitPoolSize,_).

/**
Even if the ref block is overlapping, if the loaded register is used somewhere,
it is likely a literal pool.
NOTE: We can't use `def_used` here.
*/
litpool_confidence(EA,LitPoolAddr,"litpool ref block: loaded register used somewhere"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    straight_line_def_used(EA_ldr,Reg,_,_).

/**
Even if the ref block is overlapping and there is no known use of the loaded
register, if there's a call near in the same block, it is likely a literal
pool.
Note that the use of r may not be explicit when r is only used as an argument
of a function call.
*/
litpool_confidence(EA,LitPoolAddr,"litpool ref block: possibly register param"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !overlap_with_litpool(Block),
    !straight_line_def_used(EA,_,_,_),
    code_in_block_candidate_refined(CallEA,Block),
    arch.call(CallEA,_),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    arch.integer_reg_param(Reg,_),
    CallEA <= EA + 12.

/**
If there are multiple litpool references in a block, it is likely a real code.
*/
litpool_confidence(EA,LitPoolAddr,"multiple litpool refs in a block"),
block_heuristic(Block,"code",Size,0,"multiple litpool refs in a block"):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",Size),
    Count = count :{
        code_in_block_candidate_refined(EA2,Block),
        litpool_ref(_,EA2,_,_,_,_),
        instruction_get_dest_op(EA2,_,RegOp),
        op_regdirect_contains_reg(RegOp,Reg),
        straight_line_def_used(EA2,Reg,_,_)},
    Count > 3.

/**
Currently, floating-point registers are currently not tracked in
`straight_line_def_used`.
Even if the ref block is overlapping and there is no known use of the loaded
register, if the instruction appears to be a valid VLDR, it is likely a
literal.
*/
litpool_confidence(EA,LitPoolAddr,"litpool ref block: valid VLDR"):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",_),
    !straight_line_def_used(EA_ldr,_,_,_),
    instruction_get_operation(EA_ldr,"VLDR"),
    instruction_get_dest_op(EA_ldr,_,DestRegOp),
    op_regdirect_contains_reg(DestRegOp,Reg),
    arch.float_reg(Reg,Size).

litpool_confidence(EA,LitPoolAddr,"litpool ref block: ldr_add_pc"):-
    init_ldr_add_pc(EA,_,_,LitPoolAddr,_,_).

//////////////////////////////////////////////////////////////////////////
// plausible blocks - feeds into block points

/**
Byte value '0x0000', which is "movs r0, r0", is unlikely code.
TODO: add more.
*/
contains_implausible_instr_seq(Block):-
    code_in_block_candidate_refined(EA,Block),
    instruction(EA,_,_,"MOVS",Op1,Op2,0,_,_,_),
    op_regdirect_contains_reg(Op1,"R0"),
    op_regdirect_contains_reg(Op2,"R0").


/**
Block with movw/movt pair is likely real code.
*/
contains_plausible_instr_seq(Block,"movw/movt"):-
    movw_movt_pair(EA_movw,EA_movt,_),
    code_in_block_candidate_refined(EA_movw,Block),
    code_in_block_candidate_refined(EA_movt,Block).

/**
The return register is set up, and return:
E.g,
movs r0, #0
bx lr
*/
contains_plausible_instr_seq(Block,"set-r0/return"):-
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    arch.return(EA),
    straight_line_last_def(EA,EA_def,R0),
    arch.return_reg(R0),
    EA_def < EA,
    (EA - EA_def) <= 8. // Within reasonable distance

/**
Flag-setting instruction followed by IT is likely real code:
E.g.,
cmp r0, #0
ite ne
*/
contains_plausible_instr_seq(Block,"cmp/it"):-
    code_in_block_candidate_refined(EA,Block),
    instruction_get_operation(EA,Operation),
    substr(Operation,0,2) = "IT",
    straight_line_last_def(EA,EA_def,Reg),
    arch.condition_flags_reg(Reg),
    code_in_block_candidate_refined(EA_def,Block),
    instruction_get_operation(EA_def,CmpOperation),
    arch.cmp_operation(CmpOperation).

/**
Instruction setting lr followed by jump is likely real code:
E.g.,
mov lr, pc
bx target
*/
contains_plausible_instr_seq(Block,"mov-lr-pc/jump"):-
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    arch.pc_reg(PC),
    arch.move_reg_reg(EA,"LR",PC),
    next(EA,EA_branch),
    code_in_block_candidate_refined(EA_branch,Block),
    arch.jump(EA_branch).

/**
Instruction releasing stack followed by return is likely real code:
E.g.,
sub sp, fp, #8   or   add sp, #8
pop {pc}
*/
contains_plausible_instr_seq(Block,"adjust-sp/return"):-
    arch.return(EA),
    code_in_block_candidate_refined(EA,Block),
    !arch.dangling_thumb_instr(Block),
    code_in_block_candidate_refined(EA2,Block),
    arch.stack_pointer(SP),
    (
        arch.reg_arithmetic_operation(EA2,SP,FP,_,N), N < 0,
        arch.frame_pointer(FP)
        ;
        arch.reg_arithmetic_operation(EA2,SP,SP,_,N), N > 0
    ).

/**
If a block contains multiple stack load instructions, it is likely a real
code.
*/
contains_plausible_instr_seq(Block,"multiple loads from stack"):-
    code_in_block_candidate_refined(_,Block),
    arch.stack_pointer(SP),
    Count = count :{code_in_block_candidate_refined(EA,Block),
                    arch.memory_access("LOAD",EA,_,_,_,SP,_,_,_)},
    Count > 5.


/**
The following pattern at the beginning of a block:
Block: push { ... }
EA2:   sub sp, N
*/
contains_plausible_instr_seq(Block2,"push/adjust-sp"),
contains_plausible_instr_seq(Block,"push/adjust-sp"):-
    instruction_get_operation(Block,"PUSH"),
    code_in_block_candidate_refined(Block,Block),
    must_fallthrough(Block,EA2),
    code_in_block_candidate_refined(EA2,Block2),
    arch.stack_pointer(SP),
    arch.reg_arithmetic_operation(EA2,SP,SP,_,N), N < 0.

//////////////////////////////////////////////////////////////////////////
// block points

block_heuristic(Block,"code",Size,0,Heuristic):-
    unresolved_block(Block,"code",Size),
    contains_plausible_instr_seq(Block,Type),
    !contains_implausible_instr_seq(Block),
    Heuristic = cat("plausible_block: ", Type).

block_heuristic(EA_entry,"code",Size,0,"arm: plt-block"):-
    unresolved_block(EA_entry,"code",Size),
    plt_entry_arm_candidate(EA_entry,_,_,_).

block_heuristic(EA,"code",End-Start,0,"arm: plt-block: bx pc"):-
    plt_bx_pc(EA,_),
    block_candidate_boundaries(EA,"code",Start,End).

block_heuristic(Block,"code",Size,0,"arm: plt call"):-
    plt_entry_arm_candidate(BlockDest,_,_,_),
    direct_call(EA,BlockDest),
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",Size).

/**
Similarly to the above rule, if the enclosed Thumb instruction does not have
any predecessor and the outer instruction has one, give penalty to the dangling
Thumb block.
*/
negative_block_heuristic(Block,"code",Size,0,"arm: dangling thumb instruction"):-
    unresolved_block(Block,"code",Size),
    (Block band 1) = 1, // Thumb mode only
    arch.dangling_thumb_instr(Block).

/**
It was observed that a valid ARM mode block often overlaps with a bad, small
Thumb block consisting of ADDS/SUBS/ASRS and B instrutions.
*/
negative_block_heuristic(Block,"code",Size,0,"arm: possibly invalid thumb block"):-
    unresolved_block(Block,"code",Size),
    (Block band 1) = 1, // Thumb mode only
    instruction(Block,2,_,Operation,_,_,_,_,_,_),
    (Operation = "ADDS"; Operation = "SUBS"; Operation = "ASRS"),
    next(Block,EANext),
    instruction(EANext,_,_,"B",_,_,_,_,_,_),
    align_addr(BlockAligned,Block),
    code_in_block_candidate_refined(BlockAligned,_).

/**
Control flow must not jump into the middle of an IT block.
*/
negative_block_heuristic(Block,"code",Size,0,"arm: possibly jump to in the middle of IT block"):-
    unresolved_block(Block,"code",Size),
    arch.it_conditional(JmpTarget,IT_EA),
    direct_jump(EA,JmpTarget),
    code_in_block_candidate(EA,Block),
    code_in_block_candidate_refined(JmpTarget,_),
    code_in_block_candidate_refined(IT_EA,_).

/**
There can be false positives of literal pools.
Give more points to the literal pool (data) and the ref block (code)
when it is more likely to be an actual literal pool.
*/


block_heuristic(Block,"code",Size,0,Reason):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End - Start,
    litpool_confidence(EA,LitPoolAddr,Reason).

.decl code_to_litpool_ref_point_transfer(Reason:symbol)

code_to_litpool_ref_point_transfer("litpool ref block: adr/ldm").
code_to_litpool_ref_point_transfer("litpool ref block: ldr/ldrd").
code_to_litpool_ref_point_transfer("litpool ref block: ref by non-overlapping block").
code_to_litpool_ref_point_transfer("litpool ref block: loaded register used somewhere").
code_to_litpool_ref_point_transfer("litpool ref block: possibly register param").
code_to_litpool_ref_point_transfer("litpool ref block: valid VLDR").
code_to_litpool_ref_point_transfer("litpool ref block: ldr_add_pc").

block_heuristic(LitPoolAddr,"data",Size,0,Litpool_reason):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    code_in_block_candidate_refined(EA,Block),
    block_heuristic(Block,"code",_,0,Reason),
    code_to_litpool_ref_point_transfer(Reason),
    Litpool_reason = cat("litpool: ",Reason),
    LitPoolAddr = RefAddr + LitPoolOffset.


/**
Literal pools are often placed together.
Check if there's another literal pool before or after this one.
*/
block_heuristic(Block,"code",CodeSize,0,Heuristic),
block_heuristic(LitPoolAddr,"data",Size,0,Heuristic):-
    litpool_ref(EA,_,RefAddr,LitPoolOffset,Size,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    code_in_block_candidate_refined(EA,Block),
    unresolved_block(Block,"code",CodeSize),
    !overlap_with_litpool(Block),
    (
        (Size2 = 4; Size2 = 8),
        // There is a literal pool before this one.
        litpool_boundaries(LitPoolAddr-Size2,LitPoolAddr),
        (
            // There is no literal pool after this one.
            !litpool_boundaries(LitPoolAddr+Size,_),
            Heuristic = "arm: litpool: consecutive literal pools"
            ;
            // There is a literal pool after this one.
            litpool_boundaries(LitPoolAddr+Size,_),
            Heuristic = "arm: litpool: consecutive literal pools 2"
        )
        ;
        // There is no literal pool before this one, but, there is one after.
        !litpool_boundaries(LitPoolAddr-4,LitPoolAddr),
        !litpool_boundaries(LitPoolAddr-8,LitPoolAddr),
        litpool_boundaries(LitPoolAddr+Size,_),
        Heuristic = "arm: litpool: consecutive literal pools"
    ).

block_heuristic(Block,"data",Size,0,"arm: $d symbol"):-
    defined_symbol(Block,0,_,_,_,_,_,_,"$d"),
    data_block_candidate(Block,Size).

/**
If litpool overlaps with a function symbol or $t or $a, give penalty.
*/
negative_block_heuristic(LitPoolAddr,"data",Size,0,"arm: litpool: overlapped with code symbol"):-
    litpool_boundaries(LitPoolAddr,End),
    Size = End-LitPoolAddr,
    symbol(LitPoolAddr,_,_,_,_,_,_,_,Name),
    (thumb_sym(Name); arm_sym(Name)).

block_heuristic(Block,"data",Size,0,"possible string: symbol"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    symbol(Block,_,Type,_,_,_,_,_,Name),
    Type != "FUNC",
    !thumb_sym(Name),
    !arm_sym(Name).

block_heuristic(Block,"data",Size,0,"possible string: symbol is target"):-
    block_heuristic(Block,"data",Size,0,"possible string: symbol"),
    data_block_candidate(Block,Size),
    direct_jump(_,Target), Target >= Block, Target < Block+Size.

/**
Strings are often placed together.
Check if there's another string before or after this one.
*/
block_heuristic(Block,"data",Size,0,"possible string: string pred exists"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    aligned_address_in_data(_,Block),
    ascii_string(_,End2),
    // There could be 0~3 zeros between strings.
    (
        End2 = Block
        ;
        data_byte(End2,0),
        End2 = Block - 1
        ;
        data_byte(End2,0), data_byte(End2+1,0),
        End2 = Block - 2
        ;
        data_byte(End2,0), data_byte(End2+1,0), data_byte(End2+2,0),
        End2 = Block - 3
    ).

block_heuristic(Block,"data",Size,0,"possible string: string succ exists"),
data_block_candidate(Block,Size):-
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    ascii_string(Block,End),
    Size = End-Block,
    aligned_address_in_data(_,Block),
    ascii_string(Block2,_),
    // There could be 0~3 zeros between strings.
    (
        End = Block2
        ;
        data_byte(End,0),
        End  = Block2 - 1
        ;
        data_byte(End,0), data_byte(End+1,0),
        End  = Block2 - 2
        ;
        data_byte(End,0), data_byte(End+1,0), data_byte(End+2,0),
        End  = Block2 - 3
    ).


/**
EA:     ldr r0, LitPoolAddr
...
CallEA: bl strcmp
...
LitPoolAddr: Block
...
Block: .string "..."
*/
block_heuristic(Block,"data",Size,0,"possible string: string param for string library"),
data_block_candidate(Block,Size):-
    litpool_ref(EA,EA_ldr,RefAddr,LitPoolOffset,_,_),
    LitPoolAddr = RefAddr + LitPoolOffset,
    address_in_data(LitPoolAddr,Block),
    ascii_string(Block,End),
    Size = End-Block,
    !arm_jump_table_candidate(_,_,Block,_,_,_,_,_,_),
    arch.load(EA_ldr,_,_,Reg,_,_,_,_),
    code_in_block_candidate(EA,Block2),
    code_in_block_candidate(CallEA,Block2),
    direct_call(CallEA,TargetEA),
    (
        symbol(TargetEA,_,_,_,_,_,_,_,Func)
        ;
        plt_entry_arm_candidate(TargetEA,_,Func,_)
    ),
    arch.library_string_arg(Func,Reg).

/**
E.g.,
  0:   strb r3, [r0, #53]
  4:   ldrb r3, [r5, #1]
The strb instruction is 4 bytes, and the higher 2 bytes happens
to be subs instruction, so the blocks are overlapping.
The block with strb at 0 is real and the must-through predecessor
of the block at 4.
Whereas, the subs block do not have any successor.
To give more confidence to the real block with strb,
give points 2 to the enclosing block when the enclosing block has
a must-fallthrough even if the block is overlapping.
*/
negative_block_heuristic(InnerBlock,"code",Size,0,"arm: bogus sub-instruction"):-
    unresolved_block(InnerBlock,"code",Size),
    code_in_block_candidate_refined(EnclosingEA,_),
    must_fallthrough(_,EnclosingEA),
    EnclosingEA = InnerBlock-2,
    instruction(InnerBlock,2,_,_,_,_,_,_,_,_),
    instruction(EnclosingEA,4,_,_,_,_,_,_,_,_),
    !must_fallthrough(_,InnerBlock).

/**
A return block followed by a function symbol is likely real code.
*/
block_heuristic(Block,"code",Size,0,"arm: return followed by a function"):-
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,Block),
    arch.return(EA),
    next(EA,EANext),
    function_symbol(EANext,_).

/**
`Address_in_data` with no explicit reference often happens to be ldmdaeq:
E.g.,
<  .word .L_8171bc9
<  .word .L_81501ba
---
>
>  ldmdaeq r7, { r0, r3, r6, r7, r8, sb, fp, ip }
>  ldmdaeq r5, { r1, r3, r4, r5, r7, r8 }
*/
negative_block_heuristic(Block,"code",Size,EA,"arm: ldmdaeq"):-
    code_in_block_candidate_refined(EA,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start,
    instruction_get_operation(EA,Operation),
    contains("LDM",Operation),
    (
        next(EA,EA2)
        ;
        next(EA2,EA)
    ),
    instruction_get_operation(EA2,Operation),
    instruction_get_dest_op(EA,_,DestOp1),
    op_regdirect_contains_reg(DestOp1,Reg),
    instruction_get_dest_op(EA2,_,DestOp2),
    op_regdirect_contains_reg(DestOp2,Reg).

/**
00 00 00 00 (ARM: andeq r0, r0, r0) or 00 00 (Thumb: mov r0, r0) is unlikely a real instruction.
*/
negative_block_heuristic(Block,"code",Size,Inst,"arm: contains unplausible instr"):-
    code_in_block_candidate_refined(Inst,Block),
    arch.instruction_at(EA,Inst),
    instruction(Inst,InstSize,_,_,_,_,_,_,_,_),
    data_word(EA,InstSize,0),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start.


// bkpt is an unlikely instruction to be found in a binary
negative_block_heuristic(Block,"code",Size,Inst,"arm: contains unplausible instr"):-
    instruction(Inst,_,"BKPT",_,_,_,_,_,_,_),
    code_in_block_candidate_refined(Inst,Block),
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start.

// A code block that must fall through to a function start is highly likely false.
negative_block_heuristic(Block,"code",Size,BlockSucc,"arm: must-fallthrough to function symbol"):-
    function_symbol(BlockSucc,_),
    must_fallthrough(EA,BlockSucc),
    code_in_block_candidate_refined(EA,Block),
    Block != BlockSucc,
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start.

// Same as above, but with an exidx boundary
negative_block_heuristic(Block,"code",Size,EASucc,"arm: must-fallthrough to exidx boundary"):-
    arm_exidx_entry(EASucc,0),
    arch.instruction_at(EASucc,BlockSucc),
    must_fallthrough(EA,BlockSucc),
    code_in_block_candidate_refined(EA,Block),
    Block != BlockSucc,
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start.

// Same as above, but without an explicit function symbol
negative_block_heuristic(Block,"code",Size,BlockSucc,"arm: must-fallthrough to known function start"):-
    direct_call(CallFrom,BlockSucc),
    code_in_block_candidate_refined(CallFrom,CallFromBlock),
    known_block(CallFromBlock,"code",_,_),
    !function_symbol(BlockSucc,_),
    must_fallthrough(EA,BlockSucc),
    code_in_block_candidate_refined(EA,Block),
    Block != BlockSucc,
    block_candidate_boundaries(Block,"code",Start,End),
    Size = End-Start.

block_heuristic(Block,"data",Size,0,"arm: pointer to string in data"):-
    aligned_address_in_data(Block,Addr),
    arch.pointer_size(Size),
    ascii_string(Addr,_),
    // The string does not overlap with a possible literal pool.
    align_addr(Addr_aligned,Addr),
    !litpool_boundaries(Addr_aligned,_).

/**
On top of the above, if there's another string nearby, give more points.
*/
block_heuristic(Block,"data",Size,0,"arm: pointer to string adjacent to another strings in data"):-
    block_heuristic(Block,"data",Size,0,"arm: pointer to string in data"),
    aligned_address_in_data(Block,Addr),
    (
        ascii_string(_,Addr)
        ;
        ascii_string(Addr,End),
        ascii_string(End,_)
    ).

// First data_block of the jump table gets lots of points,
// since the tbh instruction must have some corresponding entries.
block_heuristic(TableStart,"data",Size,0,Heuristic):-
    arm_jump_table_data_block(_,TableStart,TableStart,Size),
    unresolved_block(TableStart,"data",Size),
    (
        !defined_symbol(TableStart,_,_,_,_,_,_,_,"$d"),
        Heuristic = "arm: jump table: no symbol"
        ;
        // If it's a defined symbol, the points 10 are already given.
        defined_symbol(TableStart,_,_,_,_,_,_,_,"$d"),
        Heuristic = "arm: jump table"
    ).

// Subsequent data blocks compete with code blocks.
// Give a few points to encourage selection unless there's a compelling reason
// to select the code.
block_heuristic(Block,"data",Size,0,"arm: jump table: no start"):-
    arm_jump_table_data_block(_,TableStart,Block,Size),
    unresolved_block(Block,"data",Size),
    Block != TableStart.

// Give points to a jump table data block and all prior blocks if its end
// aligns with the jump table's limit (derived from targets).
block_heuristic(Block,"data",BlockSize,0,"arm: jump table fits target"):-
    // Find LastBlock where the active limit aligns with the end of the block.
    arm_jump_table_data_block(EA_jump,TableStart,LastBlock,LastBlockSize),
    arm_jump_table_candidate_start(_,EA_jump,_,_,TableStart,Size,_,_,_),
    TableEnd = LastBlock + LastBlockSize,
    (
        // Perfect alignment.
        TableLimit = TableEnd
        ;
        // Aligns, but there's an extra byte at the end of a tbb jumptable,
        // because there were an odd number of real targets.
        // Compilers may insert a zero byte to fill it.
        Size = 1,
        (TableEnd) band 1 = 1,
        TableLimit = TableEnd + 1,
        data_byte(TableEnd,0)
    ),
    LastEntryAddr = TableEnd - Size,
    arm_jump_table_candidate(EA_jump,_,TableStart,LastEntryAddr,Size,_,TableLimit,_,_),
    // Apply points to LastBlock and preceding blocks
    arm_jump_table_data_block(EA_jump,TableStart,Block,BlockSize),
    unresolved_block(Block,"data",BlockSize),
    Block <= LastBlock,
    // Don't apply this rule to first block of entries - it already gets 15 points.
    Block != TableStart.

block_heuristic(TargetEA,"code",CodeSize,0,"arm: jump table target"):-
    arm_jump_table_data_block(EA_jmp,TableStart,Block,BlockSize),
    arm_jump_table_candidate(EA_jmp,_,TableStart,DataEA,Size,TargetEA,_,_,_),
    Block <= DataEA, DataEA+Size <= Block+BlockSize,
    unresolved_block(TargetEA,"code",CodeSize).


/**
Minimum instruction size for each execution mode.

Mode can be 0 (ARM) or 1 (Thumb)
*/
.decl mode_min_instruction_size(Mode:unsigned,Size:unsigned)

// ARM
mode_min_instruction_size(0,4).
// Thumb
mode_min_instruction_size(1,2).

/**
A computed PC-relative address that isn't a jump table.

This example was generated in zlib with gcc 9.4. -Os:

    adr r1, Label
    add r2, r1, r2, lsl #4
    mov pc, r2
.Label:
    cmp r3, r1, lsl #31
    nop
    adc r0, r0, r0
    it hs
    subhs r3, r3, r1, lsl #31
.Label+16:
    cmp r3, r1, lsl #30
    nop
    adc r0, r0, r0
    it hs
    subhs r3, r3, r1, lsl #30
.Label+32:
    ...

In the above pattern, Label is supposed to be code rather than data
(literal pools).
*/
.decl branch_to_calculated_pc_rel_addr(EA:address,Dest:address)

branch_to_calculated_pc_rel_addr(EA,Dest):-
    arch.pc_relative_addr(EA,RegBase,RefAddr),
    mode_min_instruction_size(EA band 1,MinInstructionWidth),
    straight_line_def_used(EA,RegBase,EA_calc,_),
    arch.reg_reg_arithmetic_operation(EA_calc,RegJump,RegBase,_,Mult,0),
    Mult > as(MinInstructionWidth,number),
    straight_line_def_used(EA_calc,RegJump,EA_jump,JumpIndex),
    instruction_get_operation(EA_jump,JumpOperation),
    arch.jump_operation_op_index(JumpOperation,JumpIndex),
    instruction_get_op(EA_jump,JumpIndex,DestOp),
    op_regdirect_contains_reg(DestOp,RegJump),
    arch.instruction_at(RefAddr,Dest),
    code_in_block_candidate(Dest,_),
    EA band 1 = Dest band 1.

block_heuristic(Block,"code",Size,0,Heuristic):-
    branch_to_calculated_pc_rel_addr(EA,Block),
    unresolved_block(Block,"code",Size),
    code_in_block_candidate_refined(EA,BlockPred),
    (
        !unresolved_block(BlockPred,"code",_),
        !impossible_block(BlockPred,"code",_,_),
        Heuristic = "arm: calculated dest: resolved"
        ;
        unresolved_block(BlockPred,"code",_),
        Heuristic = "arm: calculated dest"
    ).
