//===- main.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This is the main module of the datalog disassembler.
The disassembly has 3 main components:
 1- code_inference.dl
    -code_inference_postprocess.dl
    -cfg.dl
 2- symbolization.pl
    - use_def_analysis.dl
    - value_analysis.dl
    - data_access_analysis.dl
    - pointer_reatribution.dl

In addition there are several modules that consider special cases,
generic components and tables.

Special cases:
    -relative_jump_tables.dl

Generic components:
    -ordered_set.dl
    -empty_range.dl

Tables:
    -float_operations.dl
    -jump_operations.dl
    -printable_chars.dl

This module:
- defines the input generated by the decoder
- defines a series of auxiliary predicates and basic facts that are used everywhere.
- defines some hard-code parameters of the analysis, such as the code and data sections
  explored.
*/

.type register <: symbol

.type address <: unsigned
.type operand_code <: unsigned
.type operand_index <: unsigned

// binary format specific predicates
#include "elf_binaries.dl"
#include "pe_binaries.dl"

// architecture specific predicates
#ifdef ARCH_ARM64
    #include "arm_binaries.dl"
    #include "arm64/arch_arm64.dl"
    .init arch = ARM64
#elif defined(ARCH_IA32)
    #include "intel/arch_x86_32.dl"
    .init arch = X86_32
#elif defined(ARCH_AMD64)
    #include "intel/arch_x86_64.dl"
    .init arch = X86_64
#else
    #error "Undefined architecture"
#endif

// tables with basic facts
#include "printable_chars.dl"


// Detection of relative jump tables
#include "relative_jump_tables.dl"

#include "exceptions.dl"

// Inference of instruction boundaries
#include "code_inference.dl"

// Performs literal-reference desambiguation
// and strings
#include "symbolization.dl"

// Inferece of function boundaries
#include "basic_function_inference.dl"

// predicates for debugging and statistics
#include "debug_stats.dl"
#include "self_diagnose.dl"
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl endianness(End:symbol) // Either LE or BE
.input endianness

.decl base_address(ea:address)
.input base_address

.decl symbol(ea:address,size:unsigned,type:symbol,scope:symbol,sectionIndex:unsigned, originTable:symbol,tableIndex:unsigned,name:symbol)
.input symbol

.decl section_complete(name:symbol,size:unsigned,addr:address,type:unsigned,flags:unsigned,align:unsigned)
.input section_complete

.decl relocation(ea:address,type:symbol,name:symbol,addend:number)
.input relocation

.decl binary_type(Type:symbol)
.input binary_type

.decl binary_format(Format:symbol)
.input binary_format

.decl binary_isa(isa:symbol)
.input binary_isa

.decl option(Option:symbol)
.input option

.decl dynamic_entry(tag:symbol, value:unsigned)
.input dynamic_entry

// instructions

.decl instruction(ea:address, size:unsigned, prefix:symbol, opcode:symbol,
          op1:operand_code, op2:operand_code, op3:operand_code, op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction

.decl invalid_op_code(ea:address)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_prefetch(code:operand_code, prefetch_type:symbol)
.input op_prefetch
.output op_prefetch

.decl op_barrier(code:operand_code, prefetch_type:symbol)
.input op_barrier
.output op_barrier

.decl op_indirect(code:operand_code,reg1:register, reg2:register, reg3:register,
        multiplier:number, offset:number, size_value:unsigned)
.input op_indirect

// data from sections
.decl data_byte(ea:address,value:unsigned)
.input data_byte

.decl address_in_data(ea:address,value:address)

.input address_in_data

///////////////////////////////////////////////////////////////
// Initialize components

.init function_inference = basic_function_inference

/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

.decl instruction_immediate_offset(EA:address,Index:operand_index,Offset:unsigned)
.output instruction_immediate_offset

instruction_immediate_offset(EA,Index,ImmediateOffset):-
    instruction(EA,_,_,_,_,_,_,_,ImmediateOffset,_),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,_).

.decl instruction_displacement_offset(EA:address,Index:operand_index,Offset:unsigned)
.output instruction_displacement_offset

instruction_displacement_offset(EA,Index,DisplacementOffset):-
    instruction(EA,_,_,_,_,_,_,_,_,DisplacementOffset),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,_,_,_,_,_,_).

.decl instruction_get_operation(ea:address,operation:symbol) inline

instruction_get_operation(EA,Operation):-
    instruction(EA,_,_,Operation,_,_,_,_,_,_).

.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)

instruction_get_op(EA,Index,Op):-
    instruction(EA,_,_,_,Op1,Op2,Op3,Op4,_,_),
    (
        Op1 != 0,
        Op = Op1, Index = 1
        ;
        Op2 != 0,
        Op = Op2, Index = 2
        ;
        Op3 != 0,
        Op = Op3, Index = 3
        ;
        Op4 != 0,
        Op = Op4, Index = 4
    ).

.decl instruction_get_dest_op(ea:address,index:number,op:operand_code)

instruction_get_dest_op(EA,Index,Op):-
    instruction(EA,_,_,Operation,_,Op2,Op3,Op4,_,_),
    !arch.read_only_operation(Operation),
    (
        Op4 = 0,
        Op3 = 0,
        Op2 != 0,
        Op = Op2,
        Index = 2
        ;
        Op4 = 0,
        Op3 != 0,
        Op = Op3,
        Index = 3
        ;
        Op4 != 0,
        Op = Op4,
        Index = 4
    ).

instruction_get_dest_op(EA,1,Op):-
    instruction(EA,_,_,Operation,Op,0,0,0,_,_),
    arch.one_op_write(Operation).

.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

//when the dest is used as a source as well
instruction_get_src_op(EA,Index,Op2):-
    instruction(EA,_,_,Operation,_,Op2,_,_,_,_),Op2 != 0,
    Index = 2,
    !arch.mov(EA),
    !arch.op_does_not_read_dest_reg(Operation),
    !arch.write_only_operation(Operation).

instruction_get_src_op(EA,Index,Op):-
    (
        instruction(EA,_,_,Operation,Op,_,_,_,_,_), Op != 0, Index = 1;
        instruction(EA,_,_,Operation,_,Op,Op3,_,_,_), Op != 0, Op3 != 0, Index = 2;
        instruction(EA,_,_,Operation,_,_,Op,Op4,_,_), Op != 0, Op4 != 0, Index = 3
    ),
    !arch.write_only_operation(Operation).


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////

.decl next(n:address,m:address)

next(EA,EA+Size):-
    instruction(EA,Size,_,_,_,_,_,_,_,_).

.decl pc_relative_operand(src:address,index:operand_index, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,Index,as(as(EANext,number)+Offset,address)):-
    binary_isa("X64"),
    instruction_get_op(EA, Index, Op),
    op_indirect(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_register(Reg),
    next(EA,EANext).

.decl got_relative_operand(EA:address,Index:operand_index,Dest:address)
.output got_relative_operand

.decl symbolic_operand_attribute(ea:address,index:unsigned,attribute:symbol)
.output symbolic_operand_attribute

.decl instruction_has_loop_prefix(EA:address)

instruction_has_loop_prefix(EA):-
    instruction(EA,_,Prefix,_,_,_,_,_,_,_),
    arch.loop_prefix(Prefix).

// JUMPS
.decl unconditional_jump(n:address)

unconditional_jump(EA):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.unconditional_jump_operation(Operation).

.decl conditional_jump(src:address)

conditional_jump(EA):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    !arch.unconditional_jump_operation(Operation).


// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,as(Dest,address)):-
    arch.jump(EA),
    arch.jump_target_op(EA,TargetOp),
    op_immediate(TargetOp,Dest).

direct_jump(EA,EA):-
    instruction_has_loop_prefix(EA).

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
    arch.jump(EA),
    pc_relative_operand(EA,1,Dest).

// jump to the address of a register
 .decl reg_jump(src:address,Reg:symbol)

reg_jump(EA,Reg):-
    arch.jump(EA),
    arch.jump_target_op(EA,TargetOp),
    op_regdirect(TargetOp,Reg).

// indirect jump
 .decl indirect_jump(src:address)

indirect_jump(EA):-
    arch.jump(EA),
    arch.jump_target_op(EA,TargetOp),
    op_indirect(TargetOp,_,_,_, _,_,_),
    !pc_relative_jump(EA,_).

// CALLS
// direct calls
.decl direct_call(src:address, dest:address)
.output direct_call

direct_call(EA,as(Dest,address)):-
    arch.call_operation(Operation),
    instruction_get_operation(EA,Operation),
    arch.jump_target_op(EA,TargetOp),
    op_immediate(TargetOp,Dest).

.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
    instruction_get_operation(Src,Operation),
    arch.call_operation(Operation),
    pc_relative_operand(Src,1,Dest).


// for now we do not compute anything about these
.decl reg_call(src:address,reg:register)
.output reg_call

reg_call(EA,Reg):-
    arch.call_operation(Operation),
    instruction_get_operation(EA,Operation),
    arch.jump_target_op(EA,TargetOp),
    op_regdirect(TargetOp,Reg).

 .decl indirect_call(src:address)
// .output indirect_call

indirect_call(EA):-
    arch.call_operation(Operation),
    instruction_get_operation(EA,Operation),
    arch.jump_target_op(EA,TargetOp),
    op_indirect(TargetOp,_,_,_,_,_,_),
    !pc_relative_call(EA,_).

// Returns
.decl return(n:address)

return(EA):-
    arch.return_operation(Operation),
    instruction_get_operation(EA,Operation).

.decl halt(EA:address)

halt(EA):-
    arch.halt_operation(Operation),
    instruction_get_operation(EA,Operation).

//////////////////////////////////////////////////////////////////////////////////
// Operations to abstract features of instructions

.decl op_indirect_contains_reg(op:operand_code,reg:register)

// we ignore segment registers
op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,Reg2,_,_,_,_),
    arch.track_register(Reg2,Reg_uniform).

op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,_,Reg3,_,_,_),
    arch.track_register(Reg3,Reg_uniform).

.decl op_regdirect_contains_reg(op:operand_code,reg:register)

op_regdirect_contains_reg(Op,Reg_uniform):-
    op_regdirect(Op,Reg),
    arch.track_register(Reg,Reg_uniform).


// The instruction at EA has operation Operation and two operands: a register Reg and an immediate Immediate
.decl op_immediate_and_reg(EA:address,Operation:symbol,Reg:register,Imm_index:operand_index,Immediate:number)

op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate):-
    instruction_get_operation(EA,Operation),
    instruction_get_op(EA,Imm_index,Op),
    op_immediate(Op,Immediate),
    instruction_get_op(EA,_,Op2),
    op_regdirect_contains_reg(Op2,Reg).

// The instruction at EA is a comparison between a register Reg and an immediate Immediate
.decl cmp_immediate_to_reg(EA:address,Reg:register,Imm_index:operand_index,Immediate:number)

cmp_immediate_to_reg(EA,Reg,Imm_index,Immediate):-
    op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate),
    arch.cmp_operation(Operation).

/////////////////////////////////////////////////////////////////////////////////

.decl symbol_set(ea:address,size:unsigned,type:symbol,scope:symbol,sectionIndex:unsigned,name:symbol)

symbol_set(EA,Size,Type,Scope,SectIndex,Name):-
    symbol(EA,Size,Type,Scope,SectIndex,_,_,Name).

.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
    symbol_set(_,_,_,_,_,Name),
    1 < count :{symbol_set(_,_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
    symbol(EA,_,"FUNC",_,_,_,_,Name).

.decl defined_symbol(ea:address,size:unsigned,type:symbol,scope:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)

defined_symbol(EA,Size,Type,Scope,SectIndex,OriginTable,TableIndex,Name):-
    symbol(EA,Size,Type,Scope,SectIndex,OriginTable,TableIndex,Name),
    SHN_UNDEF = 0,
    SHN_LORESERVE = 65280,
    SHN_HIRESERVE = 65535,
    //the symbol is not undefined
    SectIndex != SHN_UNDEF,
    (SectIndex < SHN_LORESERVE; SectIndex > SHN_HIRESERVE).

// Labels which are defined "at-end" of a data or code region/referent.
// Such labels will usually associate with a symbol at address Dest, but they
// can be safely aliased to a new symbol at the end of the Block.
.decl boundary_label(EA:address,Dest:address,Block:address)
.output boundary_label

////////////////////////////////////////////////////////////////////////////////////////

.decl section(name:symbol,size:unsigned,addr:address)
.decl data_section(name:symbol)
.decl exception_section(name:symbol)
.decl special_data_section(name:symbol)
.decl regular_data_section(name:symbol)
.decl code_section(name:symbol)
.decl tls_section(name:symbol)
.output tls_section
.decl bss_section(name:symbol)
.output bss_section

regular_data_section(Name):-
    data_section(Name),
    !special_data_section(Name).

.decl non_zero_data_section(name:symbol)
.output non_zero_data_section

.decl bss_section_limits(Begin:address,End:address)
.output bss_section_limits

bss_section_limits(0,0):-
    !bss_section(_).

bss_section_limits(Begin,LastSect+SizeLast):-
    Begin = min X:{ bss_section(Name),section(Name,_,X)},
    LastSect = max X:{ bss_section(Name),section(Name,_,X)},
    section(_,SizeLast,LastSect).

/*
data segments can be data sections or fragments of the code section that
contain data instead of code.
*/
.decl initialized_data_segment(Begin:address,End:address)
.output initialized_data_segment

initialized_data_segment(Begin,Begin+Size):-
    non_zero_data_section(Section),
    section(Section,Size,Begin).

initialized_data_segment(Begin,End):-
    data_in_code(Begin,End).

.decl data_segment(Begin:address,End:address)

data_segment(Begin,Begin+Size):-
    data_section(Section),
    section(Section,Size,Begin).

data_segment(Begin,End):-
    initialized_data_segment(Begin,End).

////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_block(block:address,function:symbol)
.output plt_block

.decl got_reference(Got_entry:address,Symbol:symbol)
.output got_reference

.decl got_local_reference(Got_entry:address,Dest:address)
.output got_local_reference

//////////////////////////////////////////////////////////////////////////
// find special functions and symbols
.decl main_function(ea:address)

.decl inferred_symbol_name(ea:address,name:symbol,scope:symbol)
.output inferred_symbol_name

inferred_symbol_name(EA,"main","GLOBAL"):-
    binary_format("ELF"),
    main_function(EA).

.decl no_return_call(EA:address)
.decl function_pointer_section(Name:symbol)

.decl no_return_function(Name:symbol)

no_return_call(EA):-
    direct_call(EA,Dest),
    plt_entry(Dest,Function),
    no_return_function(Function).

.decl is_padding(EA:address)
is_padding(EA):-
    arch.is_nop(EA).

// The functions and data-objects that are intrinsic to the compiler's ABI -
// artifacts of compilation that are not explicit features of the source and
// will likely be reintroduced by the compiler toolchain.
.decl abi_intrinsic(EA:address,Name:symbol)
.output abi_intrinsic
