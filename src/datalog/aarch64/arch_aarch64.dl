
//===- arch_aarch64.dl --------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//  Copyright (C) 2020, The Binrat Developers.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//===----------------------------------------------------------------------===//

/**
 * Define a set of predicates to model aarch64 specific instructions
 * and characteristics
 */

.comp ARM64 {

#include "jump_operations.dl"
#include "interrupt_operations.dl"
#include "registers.dl"

// TODO: these variants should be cleaned so only relevant ones are included

/* Define all variants of the move operation */
.decl move_operation(Operation:symbol)
move_operation(Operation) :-
    instruction_get_operation(_, Operation),
    contains("MOV", Operation).

/* Find all addresses where a move instruction is used */
.decl mov(EA:address)
mov(EA):-
    instruction_get_operation(EA,Operation),
    move_operation(Operation).

/* Define all variants of a conditional move operation */
/* CMOV is not used by arm64 */
.decl conditional_mov(EA:address)

/* TODO: Should all hint instructions be added? */
.decl is_nop(EA:address)
is_nop(EA):-
    instruction_get_operation(EA,"NOP").

.decl op_does_not_read_dest_reg(Operation:symbol)

.decl arithmetic_operation(Operation:symbol)

arithmetic_operation("ADD").
arithmetic_operation("SUB").
/* TODO: is 'MUL' too broad? */
arithmetic_operation("MUL").
/* TODO: is 'SHL' appropriate? See LSL/LSR/ASR/ROR */
arithmetic_operation("SHL").

.decl logic_operation(Operation:symbol)

logic_operation("AND").
logic_operation("XOR").
logic_operation("ORN").
logic_operation("EON").

.decl read_only_operation(Operation:symbol)

read_only_operation("CMP").

.decl write_only_operation(Operation:symbol)

write_only_operation("POP").

.decl one_op_write(Operation:symbol)

/* TODO: are there any ARM instructions worth adding here?
one_op_write("INC").
one_op_write("DEC").
one_op_write("POP").
*/

.decl pointer_size(n:number) inline

pointer_size(8).

.decl loop_operation(operation:symbol)

/* TODO: are there equivalents for ARM?
loop_operation("LOOP").
loop_operation("LOOPNE").
loop_operation("LOOPE").
*/

/* prefixes are not used by arm64 */
.decl loop_prefix(prefix:symbol)

.decl call_operation(operation:symbol)
call_operation("BL").

.decl syscall_operation(operation:symbol)

/* TODO: This is mapped from x86 'SYSCALL'. Is it close enough? */
syscall_operation("SVC").

.decl return_operation(operation:symbol)

return_operation("RET").

.decl halt_operation(operation:symbol)

halt_operation("HLT").

.decl cmp_operation(Operation:symbol)

cmp_operation("CMP").


// These operations are either special like LEA (does not read memory) or
// are not decoded corectly from capstone
// FIXME: review this list when capstone is updated
.decl operation_size_exception(EA:address,Op_index:number,Size:number)

/* TODO: Neither are present on ARM, but check usage of operation_size_exception
operation_size_exception(EA,Index,8):-
    instruction_get_operation(EA,"MOVSD"),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,_,_,_,_,_,32).

operation_size_exception(EA,Index,0):-
    instruction_get_operation(EA,"LEA"),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,_,_,_,_,_,_).
*/

// TODO (azreika): should be a load operation?: move_operation("ADRP").

// arithmetic operation on two source registers
.decl reg_reg_arithmetic_operation(EA:address,Reg_dest:register,Reg1:register,Reg2:register,Mult:number,Offset:number)

reg_reg_arithmetic_operation(EA,Reg2,Reg2,Reg1,-1,0):-
    instruction(EA,_,_,"SUB",Op1,Op2,0,0), Op1 != Op2,
    op_regdirect_contains_reg(Op1,Reg1),
    op_regdirect_contains_reg(Op2,Reg2).

reg_reg_arithmetic_operation(EA,Reg2,Reg1,Reg2,1,0):-
    instruction(EA,_,_,"ADD",Op1,Op2,0,0), Op1 != Op2,
    op_regdirect_contains_reg(Op2,Reg2),
    op_regdirect_contains_reg(Op1,Reg1).

reg_reg_arithmetic_operation(EA,Reg_def,Reg2,Reg1,1,0):-
    reg_reg_arithmetic_operation(EA,Reg_def,Reg1,Reg2,1,0).

}
